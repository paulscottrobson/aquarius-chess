              	; --------------------------------------
              	; zasm: assemble "m7.asm"
              	; date: 2021-10-20 17:17:34
              	; --------------------------------------


              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		m7.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		15th October 2021
              	;		Purpose :	M7 Main.
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
C000:         	CodeStart = 0xC000
FFFF:         	CodeEnd = 0xFFFF
              	
C000:         		.org CodeStart
              	
              	; ***************************************************************************************
              	;
              	; 									  Code Header
              	;
              	; ***************************************************************************************
              	
C000:         	start: 								
C000: 2A14C0  		ld 		hl,(StartAddress) 				; running from here
C003: E9      		jp 		(hl) 							
              	
C004:         	InformationBlock:
C004: 00C0    		.word 	start 							; +$00 base address of kernel
C006: 7DC0    		.word 	InterfaceHandler 				; +$02 Interface routine
C008: 0AC0    		.word 	DataArea 						; +$04 Data Area
              		
              		.include "kernel/data.asm" 				; data area.
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		data.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		15th October 2021
              	;		Purpose :	Data 
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	;										Data Area
              	;
              	; ***************************************************************************************
              	
C00A:         	DataArea:
              	;
              	; 		Current state of the 3 registers
              	;
C00A:         	RegA:
C00A: 0000    		.dw 	$0000
C00C:         	RegB:
C00C: 0000    		.dw 	$0000
C00E:         	RegC:
C00E: 0000    		.dw 	$0000
              	;
              	; 		Initial Stack Pointer
              	;
C010:         	StackPointer:
C010: FF3F    		.dw 	$3FFF
              	;
              	; 		Next free code byte
              	;
C012:         	CodeNextFree:
C012: 4BC7    		.dw 	FreeSpace
              	;
              	; 		Execute address for startup
              	;
C014:         	StartAddress:	
C014: 41C0    		.dw 	Main
              	;
              	; 		Dictionary start (works down)
              	;
C016:         	DictionaryBase:
C016: F6FD    		.dw 	DictionaryInstalledBase
              	;
              	; 		Current work trying to do
              	;
C018:         	CurrentWord:
C018: 0000    		.dw 	0
              	;
              	; 		Buffer for reading word
              	;
C01A:         	wordBuffer:
C01A: FFFFFFFF		.ds 	17
C01E: FF...   	
              	;
              	;		Buffer for error messages
              	;	
C02B:         	ErrorBuffer:
C02B: FFFFFFFF		.ds 	17
C02F: FF...   	
              	;
              	; 		Random number generator
              	;
C03C:         	seed1:
C03C: A713    		.dw 	$13A7
C03E:         	seed2:
C03E: DCFE    		.dw 	$FEDC
              	;
              	;		Image Default Colour
              	;	
C040:         	imageDefaultColour:
C040: 75      		.db 	$75
              		.include "kernel/kernel.asm"			; kernel code.	
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		kernel.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		14th October 2021
              	;		Purpose :	Kernel Main Program
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	; 									Entry point
              	;
              	; ***************************************************************************************
              	
C041:         	Main:
C041: ED7B10C0			ld 		sp,(StackPointer)			; reset Stack Pointer
C045: 211AC0  			ld 		hl,wordBuffer
C048:         	_MainRead:
C048: EDFF    			.db 	$ED,$FF 					; read character
C04A: B7      			or 		a 							; warm start if zero
C04B: 281F    			jr 		z,WarmStart
C04D: 47      			ld 		b,a 						; save
C04E: E63F    			and 	$3F
C050: FE20    			cp 		$20 						; check if it is space
C052: 28F4    			jr 		z,_MainRead 				; if so, go round again
C054:         	_MainCopy:
C054: 70      			ld 		(hl),b 						; copy word out.
C055: 23      			inc 	hl
C056: EDFF    			.db 	$ED,$FF 					; read character
C058: B7      			or 		a 							; end if zero.
C059: 2807    			jr 		z,_MainHaveWord
C05B: 47      			ld 		b,a				
C05C: E63F    			and 	$3F
C05E: FE20    			cp 		$20 						; check if it is space
C060: 20F2    			jr 		nz,_MainCopy 				; if not keep copying
C062:         	_MainHaveWord:		
C062: 3600    			ld 		(hl),$00 					; mark word end.
C064: 211AC0  			ld 		hl,wordBuffer 				; compile it
C067: CD05C1  			call 	CompileOne
C06A: 18DC    			jr 		_MainRead 					; and loop round.
              	
              	; ***************************************************************************************
              	;
              	; 										Warm Start
              	;
              	; ***************************************************************************************
              	
C06C:         	WarmStart:
C06C: AF      			xor 	a
C06D: 322BC0  			ld 		(ErrorBuffer),a
              	
              	; ***************************************************************************************
              	;
              	; 								Access the user interface
              	;
              	; ***************************************************************************************
              	
C070:         	Interface:		
C070: 212BC0  			ld 		hl,ErrorBuffer 				; point HL to Error Buffer
C073: ED7B10C0			ld 		sp,(StackPointer)			; reset Stack Pointer
C077: ED4B06C0			ld 		bc,(InformationBlock+2)
C07B: C5      			push 	bc
C07C: C9      			ret
              	
              	; ***************************************************************************************
              	;
              	; 							The default 'user interface' - nothing.
              	;
              	; ***************************************************************************************
              	
C07D:         	InterfaceHandler:		
C07D: 11EEEE  			ld 		de,$EEEE
C080: 01EEEE  			ld 		bc,$EEEE
C083: 76      			halt
C084: 18F7    			jr 		InterfaceHandler
              	;
              	; 		Word cannot be executed error
              	;
C086:         	WordIsCompileOnly:
C086: 3E43    			ld 		a,'C'
C088: 1802    			jr 		SetErrorBuffer
              	;
              	; 		Unknown word error
              	;
C08A:         	UnknownWord:
C08A: 3E3F    			ld 		a,'?'
              	;
              	; 		Report error, copy char to error buffer, then space, then current word.
              	;		
C08C:         	SetErrorBuffer:
C08C: 212BC0  			ld 		hl,ErrorBuffer
C08F: 77      			ld 		(hl),a
C090: 23      			inc 	hl
C091: 3620    			ld 		(hl),' '
C093: 23      			inc 	hl
C094: ED5B18C0			ld 		de,(CurrentWord)
C098:         	_SEBCopy:
C098: 3600    			ld 		(hl),0
C09A: 1A      			ld 		a,(de)
C09B: B7      			or  	a
C09C: 28D2    			jr 		z,Interface
C09E: E63F    			and 	$3F
C0A0: FE20    			cp 		$20
C0A2: 28CC    			jr 		z,Interface
C0A4: EE20    			xor 	$20
C0A6: C620    			add 	$20
C0A8: FE41    			cp 		'A'
C0AA: 3806    			jr 		c,_SEBNotAlpha
C0AC: FE5B    			cp 		'Z'+1
C0AE: 3002    			jr 		nc,_SEBNotAlpha
C0B0: C620    			add 	$20
C0B2:         	_SEBNotAlpha:
C0B2: 77      			ld 		(hl),a
C0B3: 23      			inc 	hl
C0B4: 13      			inc 	de
C0B5: 18E1    			jr 		_SEBCopy		
              	
              			.include 	"code.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		code.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		15th October 2021
              	;		Purpose :	Miscellaneous words
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	; 		Copy the code following (length byte first) then pop to previous level.
              	;
              	; ***************************************************************************************
              	
C0B7:         	CopyFollowing:
C0B7: E3      			ex 		(sp),hl  			 		; old HL saved on stack, HL contains length pointer
C0B8: C5      			push 	bc 							; save BC
C0B9: 46      			ld 		b,(hl) 						; get count to copy
C0BA:         	_CopyFollowing:
C0BA: 23      			inc 	hl 							; get next to copy
C0BB: 7E      			ld 		a,(hl)
C0BC: CDDDC0  			call 	CompileByte 				; and compile it.
C0BF: 10F9    			djnz 	_CopyFollowing 				; copy that many bytes.	
C0C1: C1      			pop 	bc 							; restore BC, HL
C0C2: E1      			pop 	hl 
C0C3: C9      			ret 								; return to the previous level.
              	
              	; ***************************************************************************************
              	;
              	; 							Compile call to following code
              	;
              	; ***************************************************************************************
              	
C0C4:         	CompileCallFollowing:
C0C4: 3ECD    			ld 		a,$CD 						; CD is Z80 "CALL" 
C0C6: CDDDC0  			call 	CompileByte
C0C9: E1      			pop 	hl 							; get address to compile call to
C0CA: CDCEC0  			call 	CompileWord
C0CD: C9      			ret 								; return to the previous level.
              	
              	; ***************************************************************************************
              	;
              	;									Compile HL to Code Space
              	;
              	; ***************************************************************************************
              	
C0CE:         	CompileWord:
C0CE: EB      			ex 		de,hl 						; DE contains value
C0CF: E5      			push 	hl 							; save HL
C0D0: 2A12C0  			ld 		hl,(CodeNextFree) 			; get code address
C0D3: 73      			ld 		(hl),e 						; write out
C0D4: 23      			inc 	hl 
C0D5: 72      			ld 		(hl),d
C0D6: 23      			inc 	hl
C0D7: 2212C0  			ld 		(CodeNextFree),hl 			; update code address
C0DA: E1      			pop 	hl 							; restore HL, DE
C0DB: EB      			ex 		de,hl 							
C0DC: C9      			ret
              	
              	; ***************************************************************************************
              	;
              	;									Compile A to Code Space
              	;
              	; ***************************************************************************************
              	
C0DD:         	CompileByte:
C0DD: E5      			push 	hl 							; save HL, get code address
C0DE: 2A12C0  			ld 		hl,(CodeNextFree)
C0E1: 77      			ld 		(hl),a  					; write out
C0E2: 23      			inc 	hl 							; bump & write back
C0E3: 2212C0  			ld 		(CodeNextFree),hl
C0E6: E1      			pop 	hl 	
C0E7: C9      			ret
              			.include 	"compiler.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		compiler.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		16th October 2021
              	;		Purpose :	Compile stream defining executing or compiling words 
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	; 	Compile stream at HL, executing, compiling or defining words according to their 
              	; 	colour. This is not re-entrant, as it exits to the warm start unless it goes to 
              	; 	compile something else.
              	;
              	; ***************************************************************************************
              	
C0E8:         	CompileStream:
C0E8: 7E      			ld 		a,(hl) 						; get next character
C0E9: B7      			or 		a 							; if zero, warm start as end of stream
C0EA: CA6CC0  			jp 		z,WarmStart
C0ED: 23      			inc 	hl 							; increment in case it is space
C0EE: E63F    			and 	$3F 						; check it is a coloured space.
C0F0: FE20    			cp 		$20
C0F2: 28F4    			jr 		z,CompileStream 			; if so go back
C0F4: 2B      			dec 	hl 							; undo the get, so points to the non space non zero byte.
C0F5: CD05C1  			call 	CompileOne 					; compile word at HL.
              			;
C0F8:         	_CSNext:		
C0F8: 7E      			ld 		a,(hl) 						; advance forward to next word
C0F9: B7      			or 		a 							; if found $00 end of stream go back to CompileStream
C0FA: 28EC    			jr 		z,CompileStream
C0FC: 23      			inc 	hl
C0FD: E63F    			and 	#$3F 						; check for colour space
C0FF: FE20    			cp 		$20
C101: 20F5    			jr 		nz,_CSNext
C103: 18E3    			jr 		CompileStream 				; once found, try the next word.
              	
              	; ***************************************************************************************
              	;
              	; 						  Compile/Execute/Define word at HL.
              	;
              	; ***************************************************************************************
              	
C105:         	CompileOne:
C105: 2218C0  			ld 		(CurrentWord),hl 			; useful for debugging.
C108: 7E      			ld 		a,(hl) 						; get the word's colour.
C109: E6C0    			and 	$C0
C10B: C8      			ret  	z 							; exit immediately if it's a comment word.
C10C: E5      			push 	hl 							; save HL on stack
              	
C10D: FEC0    			cp 		$C0 						; $40 and $80 , compile or execute, handled together
C10F: 203B    			jr 		nz,_COExecuteCompile
              			;
              			; 		Create a new definition using the word at HL.
              			;
C111: 06FF    			ld 		b,$FF 						; we write it out backwards so go forward counting characters. We count the space so -1 here.
C113:         	_CDFindEnd:
C113: 04      			inc 	b 							; bump count
C114: 7E      			ld 		a,(hl) 						; get character		
C115: 23      			inc 	hl
C116: B7      			or 		a
C117: 2806    			jr 		z,_CDFoundEnd		 		; if zero, we're at the end
C119: E63F    			and 	$3F
C11B: FE20    			cp 		$20
C11D: 20F4    			jr 		nz,_CDFindEnd
C11F:         	_CDFoundEnd:
              			;
              			; 		HL points one after the word end seperator, B is the count. C is the OR value for copying, which is only set 
              			; 		first time to $80
C11F: 0E80    			ld 		c,$80 						; the copy OR value
C121: 2B      			dec 	hl 							; undo the get after getting the space.
C122:         	_CDCopyDictionary:
C122: 2B      			dec 	hl 							; get previous character. we are writing out backwards as we go down
C123: 7E      			ld 		a,(hl)
C124: E63F    			and 	$3F 						; colour dropped. (should be red)
C126: B1      			or 		c  							; OR C in, first time $80
C127: 0E00    			ld 		c,0 						; and next times it's only $00		
C129: CD0DC2  			call	CompileWriteDictionary 
C12C: 10F4    			djnz 	_CDCopyDictionary 			; write out the whole word.
              			;
              			; 		Now create the rest of the record, the code address then type byte.
              			;
C12E: 3A13C0  			ld 		a,(CodeNextFree+1) 			; write out code MSB then LSB
C131: CD0DC2  			call	CompileWriteDictionary 
C134: 3A12C0  			ld 		a,(CodeNextFree)
C137: CD0DC2  			call	CompileWriteDictionary 
C13A: 3E80    			ld 		a,$80 						; then the default type byte
C13C: CD0DC2  			call	CompileWriteDictionary 
              	
C13F: 3ECD    			ld 		a,$CD 						; compile CALL CompileCallFollowing into code, the default action.
C141: CDDDC0  			call 	CompileByte 				; e.g. the word compiles a call to whatever follows it.
C144: 21C4C0  			ld 		hl,CompileCallFollowing
C147: CDCEC0  			call 	CompileWord
              	
C14A:         	_COPopHLExit:
C14A: E1      			pop 	hl 							; restore HL and exit.
C14B: C9      			ret
              	;
              	; 		Compile or execute the word at HL.
              	;
C14C:         	_COExecuteCompile:
C14C: E5      			push 	hl 							; save word text address
C14D: CD30C2  			call 	SearchDictionary 			; try to find it in the dictionary
C150: 7C      			ld 		a,h 						; was it found ?
C151: B5      			or 		l
C152: 284B    			jr 		z,_CECUnknown
              			;
              			; 		Word in the dictionary.
              			;
C154: D1      			pop 	de 							; get word text back in DE
C155: CB46    			bit 	0,(hl) 						; is this execute only ?
C157: 2808    			jr 		z,_CECNotCompileOnly
C159: 1A      			ld 		a,(de)  					; what are we doing with it ?
C15A: E6C0    			and 	$C0  						; get colour
C15C: FE80    			cp 		$80  						; if execute ?
C15E: CA86C0  			jp 		z,WordIsCompileOnly 		; then we have an error.
C161:         	_CECNotCompileOnly:		
C161: 1A      			ld 		a,(de) 						; get the word colour and save on the stack
C162: E6C0    			and 	$C0
C164: F5      			push	af
              	
C165: ED5B12C0			ld 		de,(CodeNextFree) 			; save the current code position on the stack.
C169: D5      			push 	de 
              	
C16A: CD99C1  			call 	_COCallRoutine 				; call the routine to compile what it does.
              	
C16D:         	_CEExecuteOrCompile:		
C16D: E1      			pop 	hl 							; restore code position at start to HL.
C16E: F1      			pop 	af 							; restore word colour.
              	
C16F: FE80    			cp 	 	$80 						; if not execute
C171: 20D7    			jr 	 	nz,_COPopHLExit 			; then return, as we've done the compile
              	
C173: 3EC9    			ld 		a,$C9 						; this is the Z80 RET which we need to compile after the code
C175: CDDDC0  			call 	CompileByte
C178: 2212C0  			ld 		(CodeNextFree),hl 			; reset the code pointer, as we don't want to keep this executed word.
              	
C17B: 118CC1  			ld 		de,_CEXContinue 			; go here on return
C17E: D5      			push 	de
C17F: E5      			push 	hl 							; go here, the newly compiled code, first, this is for the RET below
              	
C180: 2A0AC0  			ld 		hl,(RegA) 					; load registers
C183: ED5B0CC0			ld 		de,(RegB) 					
C187: ED4B0EC0			ld 		bc,(RegC) 					
              	
C18B: C9      			ret 								; execute the code, as we pushed HL - not actually returning :)
              	
C18C:         	_CEXContinue:
C18C: 220AC0  			ld 		(RegA),hl 					; save the registers
C18F: ED530CC0			ld 		(RegB),de
C193: ED430EC0			ld 		(RegC),bc
              	
C197: 18B1    			jr 		_COPopHLExit 				; pop HL and exit
              			;
              			; 		Call the routine to compile the code.
              			;
C199:         	_COCallRoutine:
C199: 23      			inc 	hl 							; call address into DE
C19A: 5E      			ld 		e,(hl)
C19B: 23      			inc 	hl
C19C: 56      			ld 		d,(hl)
C19D: EB      			ex 		de,hl 						; and go there
C19E:         	_COCallHL:		
C19E: E9      			jp 		(hl)
              			;
              			; 		Word not in the dictionary. Could be a constant or a string 
              			;
C19F:         	_CECUnknown:		
C19F: E1      			pop 	hl 							; restore word address.
C1A0: 7E      			ld 		a,(hl) 						; look at the first character
C1A1: E63F    			and 	$3F
C1A3: FE22    			cp 		$22 						; is it a quote, indicating a string.
C1A5: 2824    			jr 		z,_CSTRProcess 
              			;
              			; 		Now it must be a constant
              			;
C1A7: 7E      			ld 		a,(hl) 						; push the colour on the stack
C1A8: E6C0    			and 	$C0
C1AA: F5      			push 	af
C1AB: CD69C2  			call 	StringToInteger 			; convert a word to a valid integer.
C1AE: 7A      			ld 		a,d 						; DE = 0 if fail.
C1AF: B3      			or 		e
C1B0: CA8AC0  			jp 		z,UnknownWord 
              			;
C1B3: F1      			pop 	af  
C1B4: FE80    			cp 		$80 						; if execute, do execute constant.
C1B6: 2805    			jr 		z,_CECExecuteConstant
              			;
              			; 		Compile a constant inline.
              			;
C1B8:         	_CECCompileConstant:		
C1B8: CD22C2  			call 	CompileLoadConstant
C1BB: 188D    			jr 		_COPopHLExit 				; and exit
              			;
              			; 		Do the equivalent of executing a constant e.g. swap A & B n=>A
              			;
C1BD:         	_CECExecuteConstant:
C1BD: ED5B0AC0			ld 		de,(RegA) 					; A -> B
C1C1: ED530CC0			ld 		(RegB),de
C1C5: 220AC0  			ld 		(RegA),hl 					; constant -> HL
C1C8: C34AC1  			jp 		_COPopHLExit 				; and exit
              			;
              			; 		HL points to a string, prefixed by a ". Note, this is transient in execute mode.
              			;
C1CB:         	_CSTRProcess:
C1CB: 7E      			ld 		a,(hl) 						; push colour on stack
C1CC: E6C0    			and 	$C0
C1CE: F5      			push 	af
C1CF: ED5B12C0			ld 		de,(CodeNextFree) 			; save the current code position on the stack.
C1D3: D5      			push 	de 
              	
C1D4: E5      			push 	hl 							; save string address
C1D5: 3ECD    			ld 		a,$CD 						; compile CALL StringConstantHandler
C1D7: CDDDC0  			call 	CompileByte 				
C1DA: 2118C2  			ld 		hl,StringConstantHandler
C1DD: CDCEC0  			call 	CompileWord
C1E0: E1      			pop 	hl
C1E1: 23      			inc 	hl 							; skip over the initial single quote
C1E2:         	_CSTRLoop:
C1E2: 7E      			ld 		a,(hl) 						; reached the end ? either 00 orr coloured space.
C1E3: B7      			or 		a
C1E4: 2820    			jr 		z,_CSTRDone
C1E6: E63F    			and 	$3F
C1E8: FE20    			cp 		$20
C1EA: 281A    			jr 		z,_CSTRDone		
C1EC: EE20    			xor 	$20 						; convert back to ASCII 7 bit.
C1EE: C620    			add 	$20
C1F0: FE41    			cp 		'A' 						; make lower case as default.
C1F2: 3806    			jr 		c,_CSTRNotAlpha
C1F4: FE5B    			cp 		'Z'+1
C1F6: 3002    			jr 		nc,_CSTRNotAlpha
C1F8: C620    			add 	$20
C1FA:         	_CSTRNotAlpha:		
C1FA: FE5F    			cp 		'_' 						; map _ to space
C1FC: 2002    			jr 		nz,_CSTRNotBar
C1FE: 3E20    			ld 		a,' '
C200:         	_CSTRNotBar:		
C200: CDDDC0  			call 	CompileByte  				; write out
C203: 23      			inc 	hl 							; next byte
C204: 18DC    			jr 		_CSTRLoop
C206:         	_CSTRDone:
C206: AF      			xor 	a 							; write $00 end of string
C207: CDDDC0  			call 	CompileByte
C20A: C36DC1  			jp 		_CEExecuteOrCompile 		; and go do it, perhaps.		
              	
              	; ***************************************************************************************
              	;
              	; 						Write dictionary word out working downwards
              	;
              	; ***************************************************************************************
              	
C20D:         	CompileWriteDictionary:
C20D: E5      			push 	hl
C20E: 2A16C0  			ld 		hl,(DictionaryBase) 		; hence pre-decrement address.
C211: 2B      			dec 	hl
C212: 77      			ld 		(hl),a
C213: 2216C0  			ld 		(DictionaryBase),hl
C216: E1      			pop 	hl
C217: C9      			ret
              	
              	; ***************************************************************************************
              	;
              	;					 Put in HL the ASCIIZ constant following
              	;
              	; ***************************************************************************************
              	
C218:         	StringConstantHandler:
C218: EB      			ex 		de,hl
C219: E1      			pop 	hl 							; get the return address into HL, leave on stack		
C21A: E5      			push 	hl
C21B:         	_SCHEnd: 									; advance HL past the string
C21B: 7E      			ld 		a,(hl)
C21C: 23      			inc 	hl
C21D: B7      			or 		a
C21E: 20FB    			jr 		nz,_SCHEnd		
C220: E3      			ex 		(sp),hl 					; swap them round, so HL = start and (SP) is the byte after
C221: C9      			ret
              	
              	; ***************************************************************************************
              	;
              	;						Compile code to load HL as a constant
              	;
              	; ***************************************************************************************
              	
C222:         	CompileLoadConstant:
C222: 3EEB    			ld 		a,$EB 						; compile EX DE,HL
C224: CDDDC0  			call 	CompileByte
C227: 3E21    			ld 		a,$21 						; LD HL,xxxxx
C229: CDDDC0  			call 	CompileByte
C22C: CDCEC0  			call 	CompileWord 				; compile the number to load
C22F: C9      			ret
              			.include 	"search.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		find.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		16th October 2021
              	;		Purpose :	Search dictionary
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	; 		Search dictionary for word at HL, which is internal format (2+6 ended with 
              	;		(2+space or $00). On exit HL points to the type byte or $0000 if not found.
              	;
              	; ***************************************************************************************
              	
C230:         	SearchDictionary:
C230: C5      			push 	bc
C231: D5      			push 	de
C232: EB      			ex 		de,hl 						; put search string address in DE.
C233: 2A16C0  			ld 		hl,(DictionaryBase) 		; HL points to dictionary base.
              			;
              			; 		Compare entry at HL vs word at DE
              			;
C236:         	_SearchLoop:
C236: 44      			ld 		b,h 						; copy current being searched to BC
C237: 4D      			ld 		c,l 								
C238: 7E      			ld 		a,(hl) 						; get the type byte.
C239: B7      			or 	 	a 							; if zero, then fail as we've reached dictionary end.
C23A: 2827    			jr 		z,_SDFail
              			;
C23C: 23      			inc  	hl 							; point to the first character
C23D: 23      			inc 	hl 							; e.g. skip type byte and call address.
C23E: 23      			inc 	hl
C23F: D5      			push 	de 							; save search string address on stack.
              			;
              			; 		Compare string at HL vs String at DE
              			;
C240:         	_SearchCompare:
C240: 1A      			ld 		a,(de) 						; calculate xor of two characters
C241: AE      			xor 	(hl) 						; as we're only interested in lower 6 bits for compare
C242: E63F    			and 	$3F 						; check lower 6 bits only.
C244: 2015    			jr 		nz,_SearchNext 				; different, go to next word.
C246: 7E      			ld 		a,(hl) 						; get dictionary byte successfully matched.
C247: 13      			inc 	de 							; advance to next.
C248: 23      			inc 	hl 		
C249: 87      			add 	a,a 						; is bit 7 in the last match, indicating the last character of the word in the dictionary ?
C24A: 30F4    			jr 		nc,_SearchCompare 			; no, keep comparing
              			;
              			; 		Found the end of the word in the dictionary, HL points to the byte following, DE the character following.
              			;	 	We need to check it's the end of the word in the search text.
              			;
C24C: 1A      			ld 		a,(de) 						; get the next character in the search word.
C24D: D1      			pop 	de 							; having got the character, restore DE to original value.
C24E: B7      			or 		a 							; is it $00 or xx10000 (any colour space)
C24F: 2806    			jr 		z,_SDSucceed 				; if zero, we've found the word, end of buffer
C251: E63F    			and 	$3F 
C253: FE20    			cp 		$20
C255: 20DF    			jr 		nz,_SearchLoop 				; no it wasn't any Space so go round again. HL points to the next type byte already.
C257:         	_SDSucceed: 
C257: 60      			ld 		h,b 						; restore value saved in BC to HL, the type byte address of the found word.
C258: 69      			ld 		l,c  						; at the start, e.g. the address of the type byte.
C259: 180B    			jr 		_SDExit
              			;
              			; 		Names did not match. HL still points into the word.
              			;
C25B:         	_SearchNext:
C25B: 7E      			ld 		a,(hl) 						; get and bump in dictionary
C25C: 23      			inc 	hl
C25D: 87      			add 	a,a 						; looking for the bit 7 set indicating the end of the word
C25E: 30FB    			jr 		nc,_SearchNext  			
C260: D1      			pop 	de 							; restore DE, the address of the input word
C261: 18D3    			jr 		_SearchLoop 				; and try the next dictionary word.
              	;
C263:         	_SDFail:									; not found, return zero
C263: 210000  			ld 		hl,$0000 					
C266:         	_SDExit:
C266: D1      			pop 	de
C267: C1      			pop 	bc		
C268: C9      			ret		
              	
              	
              			.include 	"toint.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		toint.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		16th October 2021
              	;		Purpose :	Convert a word to an integer.
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	;		Convert word to integer. Can be decimal $hexadecimal and prefixed with '-'
              	;		Result in HL, DE is non-zero if successful.
              	;
              	; ***************************************************************************************
              	
C269:         	StringToInteger:
C269: 7E      			ld 		a,(hl) 						; check for - x
C26A: E63F    			and 	$3F
C26C: FE2D    			cp 		'-'
C26E: 200C    			jr 		nz,_STOInt
C270: 23      			inc 	hl 							; skip the - sign. 
C271: CD7CC2  			call 	_STOInt 					; try to convert to integer
              	
C274: 7C      			ld 		a,h 						; negate the result.
C275: 2F      			cpl 
C276: 67      			ld 		h,a
C277: 7D      			ld 		a,l
C278: 2F      			cpl
C279: 6F      			ld 		l,a
C27A: 23      			inc 	hl
C27B: C9      			ret
              	
C27C: DDE5    	_STOInt:push 	ix 							; save IX
              			
              	
C27E: E5      			push 	hl 							; copy word address to IX
C27F: DDE1    			pop 	ix		
C281: 01000A  			ld 		bc,10*256 					; base in B, count in C
C284: 210000  			ld 		hl,0 						; result in HL.
              			;
C287: DD7E00  			ld 		a,(ix+0) 					; is first character a '$'
C28A: E63F    			and 	$3F
C28C: FE24    			cp 		'$'
C28E: 2004    			jr 		nz,_STONotHex 
              			;
C290: 0610    			ld 		b,16 						; now Base 16.
C292: DD23    			inc 	ix 							; skip over the '$'
C294:         	_STONotHex:
              			;
              			; 		Main processing loop.
              			;		
C294:         	_STOLoop:
C294: DD7E00  			ld 		a,(ix+0) 					; get character
C297: DD23    			inc 	ix
C299: B7      			or 		a  							; check for $00 or Coloured space
C29A: 282F    			jr 		z,_STOEndWord 					
C29C: E63F    			and 	$3F
C29E: FE20    			cp 		$20
C2A0: 2829    			jr 		z,_STOEndWord
              			;
C2A2: FE3A    			cp 		'9'+1 						; if > 9 then fail
C2A4: 3029    			jr 		nc,_STOFail
C2A6: FE30    			cp 		'0'
C2A8: 3009    			jr 		nc,_STOOkay
C2AA: FE07    			cp 		6+1 						; if > F then fail
C2AC: 3021    			jr 		nc,_STOFail
C2AE: B7      			or 		a
C2AF: 281E    			jr 		z,_STOFail 					; $00 is a fail too.
C2B1: C609    			add 	9 							; maps A ($01) to ($0A) etc.
C2B3:         	_STOOkay:
C2B3: 0C      			inc 	c 							; increment successful char count		
C2B4: E60F    			and 	$0F 						; make digit in range 0..15
C2B6: B8      			cp 		b 							; fail if >= the base
C2B7: 3016    			jr 		nc,_STOFail
              			;
C2B9: 29      			add 	hl,hl 						; HL = 2 * HL
C2BA: 5D      			ld 		e,l 						; DE = 2 * HL
C2BB: 54      			ld 		d,h		
C2BC: 29      			add 	hl,hl 						; HL = 4 * HL
C2BD: 29      			add 	hl,hl 						; HL = 8 * HL
C2BE: CB60    			bit 	4,b 						; is base 16 ?
C2C0: 2802    			jr 		z,_STONotHexMult
C2C2: 5D      			ld 		e,l 						; if base 16 HL = DE = 8 * HL
C2C3: 54      			ld 		d,h
C2C4:         	_STONotHexMult:
C2C4: 19      			add 	hl,de 						; so HL = HL * 10 or * 16 depending on B
C2C5: 5F      			ld 		e,a 						; put digit in DE and add
C2C6: 1600    			ld 		d,0
C2C8: 19      			add 	hl,de
C2C9: 18C9    			jr 		_STOLoop
              	;
C2CB:         	_STOEndWord:
C2CB: 59      			ld 		e,c 						; E is 0 if no chars, e.g. fail or #0 if chars consumed
C2CC: 51      			ld 		d,c 						; D the same
C2CD: 1806    			jr 		_STOExit 					; and exit
              	
C2CF:         	_STOFail:	 								; can't do it, return DE = HL = 0	
C2CF: 110000  			ld 		de,0
C2D2: 210000  			ld 		hl,0
C2D5:         	_STOExit:		
C2D5: DDE1    			pop 	ix 							; restore IX and exit
C2D7: C9      			ret
              	
              			
              		
              	
              	; ***************************************************************************************
              	;
              	; 							Autogenerated Vocabulary file
              	;
              	; ***************************************************************************************
              	
              		.include 	"vocabulary/vocabulary.asm"
              	; --------------------------------------
              	;             <
              	; --------------------------------------
C2D8:         	word_1000:
C2D8: CDC4C0  		call	CompileCallFollowing
C2DB: 7C      	 ld   a,h           ; check if signs different.
C2DC: AA      	 xor  d
C2DD: 87      	 add  a,a          ; CS if different
C2DE: 3004    	 jr   nc,__less_samesign
C2E0: 7A      	 ld   a,d          ; different. set CS to sign of B
C2E1: 87      	 add  a,a          ; if set (negative) B must be < A as A is +ve
C2E2: 1805    	 jr   __less_returnc
C2E4:         	__less_samesign:
C2E4: D5      	 push  de           ; save DE
C2E5: EB      	 ex   de,hl          ; -1 if B < A
C2E6: ED52    	 sbc  hl,de          ; calculate B - A , hencs CS if < (Carry clear by add a,a)
C2E8: D1      	 pop  de           ; restore DE
C2E9:         	__less_returnc:
C2E9: 3E00    	 ld   a,0          ; A 0
C2EB: DE00    	 sbc  a,0          ; A $FF if CS.
C2ED: 6F      	 ld   l,a          ; put in HL
C2EE: 67      	 ld   h,a
C2EF: C9      	 ret
              	; --------------------------------------
              	;             =
              	; --------------------------------------
C2F0:         	word_1001:
C2F0: CDC4C0  		call	CompileCallFollowing
C2F3: 7C      	 ld   a,h          ; H = H ^ D
C2F4: AA      	 xor  d
C2F5: 67      	 ld   h,a
C2F6: 7D      	 ld   a,l          ; A = (L ^ E) | (H ^ D)
C2F7: AB      	 xor  e
C2F8: B4      	 or   h           ; if A == 0 they are the same.
C2F9: 210000  	 ld   hl,$0000         ; return 0 if different
C2FC: C0      	 ret  nz
C2FD: 2B      	 dec  hl           ; return -1
C2FE: C9      	 ret
              	; --------------------------------------
              	;             -
              	; --------------------------------------
C2FF:         	word_1002:
C2FF: CDC4C0  		call	CompileCallFollowing
C302: D5      	 push  de           ; save DE
C303: EB      	 ex   de,hl          ; HL = B, DE = A
C304: AF      	 xor  a            ; clear carry
C305: ED52    	 sbc  hl,de          ; calculate B-A
C307: D1      	 pop  de           ; restore DE
C308: C9      	 ret
              	; --------------------------------------
              	;             +
              	; --------------------------------------
C309:         	word_1003:
C309: CDB7C0  		call	CopyFollowing
C30C: 01      		.db	endcopy_1003 - $ - 1
C30D: 19      	 add  hl,de
C30E:         	endcopy_1003:
              	; --------------------------------------
              	;             AND
              	; --------------------------------------
C30E:         	word_1004:
C30E: CDC4C0  		call	CompileCallFollowing
C311: 7C      	 ld   a,h
C312: A2      	 and  d
C313: 67      	 ld   h,a
C314: 7D      	 ld   a,l
C315: A3      	 and  e
C316: 6F      	 ld   l,a
C317: C9      	 ret
              	; --------------------------------------
              	;             OR
              	; --------------------------------------
C318:         	word_1005:
C318: CDC4C0  		call	CompileCallFollowing
C31B: 7C      	 ld   a,h
C31C: B2      	 or   d
C31D: 67      	 ld   h,a
C31E: 7D      	 ld   a,l
C31F: B3      	 or   e
C320: 6F      	 ld   l,a
C321: C9      	 ret
              	; --------------------------------------
              	;             XOR
              	; --------------------------------------
C322:         	word_1006:
C322: CDC4C0  		call	CompileCallFollowing
C325: 7C      	 ld   a,h
C326: AA      	 xor  d
C327: 67      	 ld   h,a
C328: 7D      	 ld   a,l
C329: AB      	 xor  e
C32A: 6F      	 ld   l,a
C32B: C9      	 ret
              	; --------------------------------------
              	;             /
              	; --------------------------------------
C32C:         	word_1007:
C32C: CDC4C0  		call	CompileCallFollowing
C32F: D5      	 push  de
C330: CDFFC5  	 call  DIVDivideMod16
C333: EB      	 ex   de,hl
C334: D1      	 pop  de
C335: C9      	 ret
              	; --------------------------------------
              	;             MOD
              	; --------------------------------------
C336:         	word_1008:
C336: CDC4C0  		call	CompileCallFollowing
C339: D5      	 push  de
C33A: CDFFC5  	 call  DIVDivideMod16
C33D: D1      	 pop  de
C33E: C9      	 ret
              	; --------------------------------------
              	;             !
              	; --------------------------------------
C33F:         	word_1009:
C33F: CDB7C0  		call	CopyFollowing
C342: 04      		.db	endcopy_1009 - $ - 1
C343: 73      	  ld   (hl),e
C344: 23      	  inc  hl
C345: 72      	  ld   (hl),d
C346: 2B      	  dec  hl
C347:         	endcopy_1009:
              	; --------------------------------------
              	;             @
              	; --------------------------------------
C347:         	word_1010:
C347: CDB7C0  		call	CopyFollowing
C34A: 04      		.db	endcopy_1010 - $ - 1
C34B: 7E      	  ld   a,(hl)
C34C: 23      	  inc  hl
C34D: 66      	  ld  h,(hl)
C34E: 6F      	  ld  l,a
C34F:         	endcopy_1010:
              	; --------------------------------------
              	;             +!
              	; --------------------------------------
C34F:         	word_1011:
C34F: CDC4C0  		call	CompileCallFollowing
C352: 7E      	  ld   a,(hl)
C353: 83      	  add  a,e
C354: 77      	  ld   (hl),a
C355: 23      	  inc  hl
C356: 7E      	  ld   a,(hl)
C357: 8A      	  adc  a,d
C358: 77      	  ld   (hl),a
C359: 2B      	  dec  hl
C35A: C9      	  ret
              	; --------------------------------------
              	;             C!
              	; --------------------------------------
C35B:         	word_1012:
C35B: CDB7C0  		call	CopyFollowing
C35E: 01      		.db	endcopy_1012 - $ - 1
C35F: 73      	  ld   (hl),e
C360:         	endcopy_1012:
              	; --------------------------------------
              	;             C@
              	; --------------------------------------
C360:         	word_1013:
C360: CDB7C0  		call	CopyFollowing
C363: 03      		.db	endcopy_1013 - $ - 1
C364: 6E      	  ld   l,(hl)
C365: 2600    	  ld   h,0
C367:         	endcopy_1013:
              	; --------------------------------------
              	;             P@
              	; --------------------------------------
C367:         	word_1014:
C367: CDC4C0  		call	CompileCallFollowing
C36A: C5      	  push  bc
C36B: 44      	  ld  b,h
C36C: 4D      	  ld   c,l
C36D: ED68    	  in   l,(c)
C36F: 2600    	  ld   h,0
C371: C1      	  pop  bc
C372: C9      	  ret
              	; --------------------------------------
              	;             P!
              	; --------------------------------------
C373:         	word_1015:
C373: CDC4C0  		call	CompileCallFollowing
C376: C5      	  push  bc
C377: E5      	  push  hl
C378: 7B      	  ld   a,e
C379: 44      	  ld  b,h
C37A: 4D      	  ld   c,l
C37B: ED79    	  out  (c),a
C37D: E1      	  pop  hl
C37E: C1      	  pop  bc
C37F: C9      	  ret
              	; --------------------------------------
              	;             ,
              	; --------------------------------------
C380:         	word_1016:
C380: CDC4C0  		call	CompileCallFollowing
C383: C3CEC0  	  jp   CompileWord
              	; --------------------------------------
              	;             ;
              	; --------------------------------------
C386:         	word_1017:
C386: 3EC9    	  ld   a,$C9         ; compile a RET
C388: CDDDC0  	  call  CompileByte
              	  ; TODO: Check close to $E000,  so we can skip the ROM header.
C38B: C9      	  ret
              	; --------------------------------------
              	;             C,
              	; --------------------------------------
C38C:         	word_1018:
C38C: CDC4C0  		call	CompileCallFollowing
C38F: 7D      	  ld   a,l
C390: C3DDC0  	  jp   CompileByte
              	; --------------------------------------
              	;             COPY
              	; --------------------------------------
C393:         	word_1019:
C393: CDC4C0  		call	CompileCallFollowing
C396: 78      	  ld   a,b         ; exit if C = 0
C397: B1      	  or   c
C398: C8      	  ret  z
              	
C399: C5      	  push  bc          ; BC count
C39A: D5      	  push  de          ; DE target
C39B: E5      	  push  hl          ; HL source
              	
C39C: AF      	  xor  a          ; Clear C
C39D: ED52    	  sbc  hl,de         ; check overlap ?
C39F: 300B    	  jr   nc,__copy_gt_count      ; if source after target
C3A1: 19      	  add  hl,de         ; undo subtract
              	
C3A2: 09      	  add  hl,bc         ; add count to HL + DE
C3A3: EB      	  ex   de,hl
C3A4: 09      	  add  hl,bc
C3A5: EB      	  ex   de,hl
C3A6: 1B      	  dec  de          ; dec them, so now at the last byte to copy
C3A7: 2B      	  dec  hl
C3A8: EDB8    	  lddr           ; do it backwards
C3AA: 1803    	  jr   __copy_exit
              	
C3AC:         	__copy_gt_count:
C3AC: 19      	  add  hl,de         ; undo subtract
C3AD: EDB0    	  ldir          ; do the copy
C3AF:         	__copy_exit:
C3AF: E1      	  pop  hl          ; restore registers
C3B0: D1      	  pop  de
C3B1: C1      	  pop  bc
C3B2: C9      	  ret
              	; --------------------------------------
              	;             FILL
              	; --------------------------------------
C3B3:         	word_1020:
C3B3: CDC4C0  		call	CompileCallFollowing
C3B6: 78      	  ld   a,b         ; exit if C = 0
C3B7: B1      	  or   c
C3B8: C8      	  ret  z
              	
C3B9: C5      	  push  bc          ; BC count
C3BA: D5      	  push  de          ; DE target, L byte
C3BB:         	__fill_loop:
C3BB: 7D      	  ld   a,l         ; copy a byte
C3BC: 12      	  ld   (de),a
C3BD: 13      	  inc  de          ; bump pointer
C3BE: 0B      	  dec  bc          ; dec counter and loop
C3BF: 78      	  ld   a,b
C3C0: B1      	  or   c
C3C1: 20F8    	  jr   nz,__fill_loop
C3C3: D1      	  pop  de          ; restore
C3C4: C1      	  pop  bc
C3C5: C9      	  ret
              	; --------------------------------------
              	;             HALT
              	; --------------------------------------
C3C6:         	word_1021:
C3C6: CDC4C0  		call	CompileCallFollowing
C3C9:         	__halt_loop:
C3C9: F3      	  di
C3CA: 76      	  halt
C3CB: 18FC    	  jr   __halt_loop
              	; --------------------------------------
              	;             BREAK
              	; --------------------------------------
C3CD:         	word_1022:
C3CD: CDB7C0  		call	CopyFollowing
C3D0: 01      		.db	endcopy_1022 - $ - 1
C3D1: 76      	  db   $76
C3D2:         	endcopy_1022:
              	; --------------------------------------
              	;             *
              	; --------------------------------------
C3D2:         	word_1023:
C3D2: CDC4C0  		call	CompileCallFollowing
C3D5: C32AC6  	 jp   MULTMultiply16
              	; --------------------------------------
              	;             SWAP
              	; --------------------------------------
C3D8:         	word_1024:
C3D8: CDB7C0  		call	CopyFollowing
C3DB: 01      		.db	endcopy_1024 - $ - 1
C3DC: EB      	  ex   de,hl
C3DD:         	endcopy_1024:
              	; --------------------------------------
              	;             A>B
              	; --------------------------------------
C3DD:         	word_1025:
C3DD: CDB7C0  		call	CopyFollowing
C3E0: 02      		.db	endcopy_1025 - $ - 1
C3E1: 54      	  ld   d,h
C3E2: 5D      	  ld   e,l
C3E3:         	endcopy_1025:
              	; --------------------------------------
              	;             A>C
              	; --------------------------------------
C3E3:         	word_1026:
C3E3: CDB7C0  		call	CopyFollowing
C3E6: 02      		.db	endcopy_1026 - $ - 1
C3E7: 44      	  ld   b,h
C3E8: 4D      	  ld   c,l
C3E9:         	endcopy_1026:
              	; --------------------------------------
              	;             B>A
              	; --------------------------------------
C3E9:         	word_1027:
C3E9: CDB7C0  		call	CopyFollowing
C3EC: 02      		.db	endcopy_1027 - $ - 1
C3ED: 62      	  ld   h,d
C3EE: 6B      	  ld   l,e
C3EF:         	endcopy_1027:
              	; --------------------------------------
              	;             B>C
              	; --------------------------------------
C3EF:         	word_1028:
C3EF: CDB7C0  		call	CopyFollowing
C3F2: 02      		.db	endcopy_1028 - $ - 1
C3F3: 42      	  ld   b,d
C3F4: 4B      	  ld   c,e
C3F5:         	endcopy_1028:
              	; --------------------------------------
              	;             C>A
              	; --------------------------------------
C3F5:         	word_1029:
C3F5: CDB7C0  		call	CopyFollowing
C3F8: 02      		.db	endcopy_1029 - $ - 1
C3F9: 60      	  ld   h,b
C3FA: 69      	  ld   l,c
C3FB:         	endcopy_1029:
              	; --------------------------------------
              	;             C>B
              	; --------------------------------------
C3FB:         	word_1030:
C3FB: CDB7C0  		call	CopyFollowing
C3FE: 02      		.db	endcopy_1030 - $ - 1
C3FF: 50      	  ld   d,b
C400: 59      	  ld   e,c
C401:         	endcopy_1030:
              	; --------------------------------------
              	;             PUSH
              	; --------------------------------------
C401:         	word_1031:
C401: CDB7C0  		call	CopyFollowing
C404: 01      		.db	endcopy_1031 - $ - 1
C405: E5      	 push  hl
C406:         	endcopy_1031:
              	; --------------------------------------
              	;             POP
              	; --------------------------------------
C406:         	word_1032:
C406: CDB7C0  		call	CopyFollowing
C409: 02      		.db	endcopy_1032 - $ - 1
C40A: EB      	 ex   de,hl
C40B: E1      	 pop  hl
C40C:         	endcopy_1032:
              	; --------------------------------------
              	;             A>R
              	; --------------------------------------
C40C:         	word_1033:
C40C: CDB7C0  		call	CopyFollowing
C40F: 01      		.db	endcopy_1033 - $ - 1
C410: E5      	 push  hl
C411:         	endcopy_1033:
              	; --------------------------------------
              	;             R>A
              	; --------------------------------------
C411:         	word_1034:
C411: CDB7C0  		call	CopyFollowing
C414: 01      		.db	endcopy_1034 - $ - 1
C415: E1      	 pop  hl
C416:         	endcopy_1034:
              	; --------------------------------------
              	;             B>R
              	; --------------------------------------
C416:         	word_1035:
C416: CDB7C0  		call	CopyFollowing
C419: 01      		.db	endcopy_1035 - $ - 1
C41A: D5      	 push  de
C41B:         	endcopy_1035:
              	; --------------------------------------
              	;             R>B
              	; --------------------------------------
C41B:         	word_1036:
C41B: CDB7C0  		call	CopyFollowing
C41E: 01      		.db	endcopy_1036 - $ - 1
C41F: D1      	 pop  de
C420:         	endcopy_1036:
              	; --------------------------------------
              	;             C>R
              	; --------------------------------------
C420:         	word_1037:
C420: CDB7C0  		call	CopyFollowing
C423: 01      		.db	endcopy_1037 - $ - 1
C424: C5      	 push  bc
C425:         	endcopy_1037:
              	; --------------------------------------
              	;             R>C
              	; --------------------------------------
C425:         	word_1038:
C425: CDB7C0  		call	CopyFollowing
C428: 01      		.db	endcopy_1038 - $ - 1
C429: C1      	 pop  bc
C42A:         	endcopy_1038:
              	; --------------------------------------
              	;             AB>R
              	; --------------------------------------
C42A:         	word_1039:
C42A: CDB7C0  		call	CopyFollowing
C42D: 02      		.db	endcopy_1039 - $ - 1
C42E: D5      	 push  de
C42F: E5      	 push  hl
C430:         	endcopy_1039:
              	; --------------------------------------
              	;             R>AB
              	; --------------------------------------
C430:         	word_1040:
C430: CDB7C0  		call	CopyFollowing
C433: 02      		.db	endcopy_1040 - $ - 1
C434: E1      	 pop  hl
C435: D1      	 pop  de
C436:         	endcopy_1040:
              	; --------------------------------------
              	;             ABC>R
              	; --------------------------------------
C436:         	word_1041:
C436: CDB7C0  		call	CopyFollowing
C439: 03      		.db	endcopy_1041 - $ - 1
C43A: C5      	 push  bc
C43B: D5      	 push  de
C43C: E5      	 push  hl
C43D:         	endcopy_1041:
              	; --------------------------------------
              	;             R>ABC
              	; --------------------------------------
C43D:         	word_1042:
C43D: CDB7C0  		call	CopyFollowing
C440: 03      		.db	endcopy_1042 - $ - 1
C441: E1      	 pop  hl
C442: D1      	 pop  de
C443: C1      	 pop  bc
C444:         	endcopy_1042:
              	; --------------------------------------
              	;             H
              	; --------------------------------------
C444:         	word_1043:
C444: CDB7C0  		call	CopyFollowing
C447: 04      		.db	endcopy_1043 - $ - 1
C448: EB      	  ex  de,hl
C449: 2112C0  	  ld  hl,CodeNextFree
C44C:         	endcopy_1043:
              	; --------------------------------------
              	;             $SYSTEM
              	; --------------------------------------
C44C:         	word_1044:
C44C: CDB7C0  		call	CopyFollowing
C44F: 04      		.db	endcopy_1044 - $ - 1
C450: EB      	  ex  de,hl
C451: 2104C0  	  ld  hl,InformationBlock
C454:         	endcopy_1044:
              	; --------------------------------------
              	;             $DICTIONARY
              	; --------------------------------------
C454:         	word_1045:
C454: CDB7C0  		call	CopyFollowing
C457: 04      		.db	endcopy_1045 - $ - 1
C458: EB      	  ex  de,hl
C459: 2A16C0  	  ld  hl,(DictionaryBase)
C45C:         	endcopy_1045:
              	; --------------------------------------
              	;             WARM.START
              	; --------------------------------------
C45C:         	word_1046:
C45C: CDC4C0  		call	CompileCallFollowing
C45F: C36CC0  	  jp   WarmStart
              	; --------------------------------------
              	;             REPORT.ERROR
              	; --------------------------------------
C462:         	word_1047:
C462: CDC4C0  		call	CompileCallFollowing
C465: C370C0  	  jp   Interface
              	; --------------------------------------
              	;             $COMPILER
              	; --------------------------------------
C468:         	word_1048:
C468: CDC4C0  		call	CompileCallFollowing
C46B: C3E8C0  	  jp   CompileStream
              	; --------------------------------------
              	;             CONSTANT
              	; --------------------------------------
C46E:         	word_1049:
C46E: 2A12C0  	  ld   hl,(CodeNextFree)    ; fix up definition to remove call address.
C471: 2B      	  dec  hl
C472: 2B      	  dec  hl
C473: 2212C0  	  ld   (CodeNextFree),hl    ; keeping the CALL opcode.
              	  ;
C476: 2144C6  	  ld   hl,ConstantHandler    ; make it CALL ConstantHandler
C479: CDCEC0  	  call  CompileWord
C47C: 2A0AC0  	  ld   hl,(RegA)     ; and put the word in after.
C47F: CDCEC0  	  call  CompileWord
C482: C9      	  ret
              	; --------------------------------------
              	;             VARIABLE
              	; --------------------------------------
C483:         	word_1050:
C483: 2A12C0  	  ld   hl,(CodeNextFree)    ; fix up definition to remove call address.
C486: 2B      	  dec  hl
C487: 2B      	  dec  hl
C488: 2212C0  	  ld   (CodeNextFree),hl    ; keeping the CALL opcode.
              	  ;
C48B: 2157C6  	  ld   hl,VariableHandler    ; make it CALL VariableHandler
C48E: CDCEC0  	  call  CompileWord
C491: 210000  	  ld   hl,$0000     ; initialise to zero.
C494: CDCEC0  	  call  CompileWord
C497: C9      	  ret
              	; --------------------------------------
              	;             DATA
              	; --------------------------------------
C498:         	word_1051:
C498: 2A12C0  	  ld   hl,(CodeNextFree)    ; fix up definition to remove call address.
C49B: 2B      	  dec  hl
C49C: 2B      	  dec  hl
C49D: 2212C0  	  ld   (CodeNextFree),hl    ; keeping the CALL opcode.
              	  ;
C4A0: 2157C6  	  ld   hl,VariableHandler    ; make it CALL VariableHandler
C4A3: CDCEC0  	  call  CompileWord
C4A6: C9      	  ret
              	; --------------------------------------
              	;             ARRAY
              	; --------------------------------------
C4A7:         	word_1052:
C4A7: 2A12C0  	  ld   hl,(CodeNextFree)    ; fix up definition to remove call address.
C4AA: 2B      	  dec  hl
C4AB: 2B      	  dec  hl
C4AC: 2212C0  	  ld   (CodeNextFree),hl    ; keeping the CALL opcode.
              	  ;
C4AF: 2157C6  	  ld   hl,VariableHandler    ; make it CALL VariableHandler
C4B2: CDCEC0  	  call  CompileWord
              	
C4B5: 2A0AC0  	  ld   hl,(RegA)     ; initialise to zero.
C4B8:         	_MakeArray:
C4B8: 7C      	  ld   a,h
C4B9: B5      	  or   l
C4BA: C8      	  ret  z
C4BB: 2B      	  dec  hl
C4BC: AF      	  xor  a
C4BD: CDDDC0  	  call  CompileByte
C4C0: 18F6    	  jr   _MakeArray
C4C2: C9      	  ret
              	; --------------------------------------
              	;             ADDRESS.OF
              	; --------------------------------------
C4C3:         	word_1053:
C4C3: D5      	  push  de
C4C4: E5      	  push  hl
C4C5: 2A12C0  	  ld   hl,(CodeNextFree)    ; get previous code address
C4C8: 2B      	  dec  hl
C4C9: 56      	  ld   d,(hl)
C4CA: 2B      	  dec  hl
C4CB: 5E      	  ld   e,(hl)
C4CC: 2B      	  dec  hl
C4CD: 2212C0  	  ld   (CodeNextFree),hl    ; we've removed the word, address is in DE
C4D0: EB      	  ex   de,hl
C4D1: CD22C2  	  call  CompileLoadConstant
C4D4: E1      	  pop  hl
C4D5: D1      	  pop  de
C4D6: C9      	  ret
              	; --------------------------------------
              	;             !!
              	; --------------------------------------
C4D7:         	word_1054:
C4D7: 2A12C0  	  ld   hl,(CodeNextFree)    ; we save one byte.
C4DA: 2B      	  dec  hl
C4DB: 2212C0  	  ld   (CodeNextFree),hl
              	  ;
C4DE: 46      	  ld   b,(hl)
C4DF: 2B      	  dec  hl
C4E0: 4E      	  ld   c,(hl)
C4E1: 70      	  ld   (hl),b
C4E2: 2B      	  dec  hl
C4E3: 71      	  ld   (hl),c
C4E4: 2B      	  dec  hl
C4E5: 3622    	  ld   (hl),$22
C4E7: C9      	  ret
              	; --------------------------------------
              	;             @@
              	; --------------------------------------
C4E8:         	word_1055:
C4E8: 2A12C0  	  ld   hl,(CodeNextFree)    ; we save one byte.
              	  ;
C4EB: 2B      	  dec  hl
C4EC: 2B      	  dec  hl
C4ED: 2B      	  dec  hl
C4EE: 362A    	  ld   (hl),$2A
C4F0: C9      	  ret
              	; --------------------------------------
              	;             ---
              	; --------------------------------------
C4F1:         	word_1056:
C4F1: CDB7C0  		call	CopyFollowing
C4F4: 02      		.db	endcopy_1056 - $ - 1
C4F5: 2B      	  dec  hl
C4F6: 2B      	  dec  hl
C4F7:         	endcopy_1056:
              	; --------------------------------------
              	;             --
              	; --------------------------------------
C4F7:         	word_1057:
C4F7: CDB7C0  		call	CopyFollowing
C4FA: 01      		.db	endcopy_1057 - $ - 1
C4FB: 2B      	  dec  hl
C4FC:         	endcopy_1057:
              	; --------------------------------------
              	;             ++
              	; --------------------------------------
C4FC:         	word_1058:
C4FC: CDB7C0  		call	CopyFollowing
C4FF: 01      		.db	endcopy_1058 - $ - 1
C500: 23      	  inc  hl
C501:         	endcopy_1058:
              	; --------------------------------------
              	;             +++
              	; --------------------------------------
C501:         	word_1059:
C501: CDB7C0  		call	CopyFollowing
C504: 02      		.db	endcopy_1059 - $ - 1
C505: 23      	  inc  hl
C506: 23      	  inc  hl
C507:         	endcopy_1059:
              	; --------------------------------------
              	;             0-
              	; --------------------------------------
C507:         	word_1060:
C507: CDC4C0  		call	CompileCallFollowing
C50A:         	__negate:
C50A: 7C      	  ld   a,h
C50B: 2F      	  cpl
C50C: 67      	  ld   h,a
C50D: 7D      	  ld   a,l
C50E: 2F      	  cpl
C50F: 6F      	  ld   l,a
C510: 23      	  inc  hl
C511: C9      	  ret
              	; --------------------------------------
              	;             0<
              	; --------------------------------------
C512:         	word_1061:
C512: CDC4C0  		call	CompileCallFollowing
C515: CB7C    	  bit  7,h
C517: 210000  	  ld   hl,$0000
C51A: C8      	  ret  z
C51B: 2B      	  dec  hl
C51C: C9      	  ret
              	; --------------------------------------
              	;             0=
              	; --------------------------------------
C51D:         	word_1062:
C51D: CDC4C0  		call	CompileCallFollowing
C520: 7C      	  ld   a,h
C521: B5      	  or   l
C522: 210000  	  ld   hl,$0000
C525: C0      	  ret  nz
C526: 2B      	  dec  hl
C527: C9      	  ret
              	; --------------------------------------
              	;             2*
              	; --------------------------------------
C528:         	word_1063:
C528: CDB7C0  		call	CopyFollowing
C52B: 01      		.db	endcopy_1063 - $ - 1
C52C: 29      	  add  hl,hl
C52D:         	endcopy_1063:
              	; --------------------------------------
              	;             4*
              	; --------------------------------------
C52D:         	word_1064:
C52D: CDB7C0  		call	CopyFollowing
C530: 02      		.db	endcopy_1064 - $ - 1
C531: 29      	  add  hl,hl
C532: 29      	  add  hl,hl
C533:         	endcopy_1064:
              	; --------------------------------------
              	;             8*
              	; --------------------------------------
C533:         	word_1065:
C533: CDB7C0  		call	CopyFollowing
C536: 03      		.db	endcopy_1065 - $ - 1
C537: 29      	  add  hl,hl
C538: 29      	  add  hl,hl
C539: 29      	  add  hl,hl
C53A:         	endcopy_1065:
              	; --------------------------------------
              	;             16*
              	; --------------------------------------
C53A:         	word_1066:
C53A: CDB7C0  		call	CopyFollowing
C53D: 04      		.db	endcopy_1066 - $ - 1
C53E: 29      	  add  hl,hl
C53F: 29      	  add  hl,hl
C540: 29      	  add  hl,hl
C541: 29      	  add  hl,hl
C542:         	endcopy_1066:
              	; --------------------------------------
              	;             2/
              	; --------------------------------------
C542:         	word_1067:
C542: CDB7C0  		call	CopyFollowing
C545: 04      		.db	endcopy_1067 - $ - 1
C546: CB2C    	  sra  h
C548: CB1D    	  rr   l
C54A:         	endcopy_1067:
              	; --------------------------------------
              	;             4/
              	; --------------------------------------
C54A:         	word_1068:
C54A: CDB7C0  		call	CopyFollowing
C54D: 08      		.db	endcopy_1068 - $ - 1
C54E: CB2C    	  sra  h
C550: CB1D    	  rr   l
C552: CB2C    	  sra  h
C554: CB1D    	  rr   l
C556:         	endcopy_1068:
              	; --------------------------------------
              	;             ABS
              	; --------------------------------------
C556:         	word_1069:
C556: CDC4C0  		call	CompileCallFollowing
C559: CB7C    	  bit  7,h
C55B: C8      	  ret  z
C55C: C30AC5  	  jp   __negate
              	; --------------------------------------
              	;             BSWAP
              	; --------------------------------------
C55F:         	word_1070:
C55F: CDB7C0  		call	CopyFollowing
C562: 03      		.db	endcopy_1070 - $ - 1
C563: 7D      	  ld   a,l
C564: 6C      	  ld   l,h
C565: 67      	  ld   h,a
C566:         	endcopy_1070:
              	; --------------------------------------
              	;             NOT
              	; --------------------------------------
C566:         	word_1071:
C566: CDC4C0  		call	CompileCallFollowing
C569: 7C      	  ld   a,h
C56A: 2F      	  cpl
C56B: 67      	  ld   h,a
C56C: 7D      	  ld   a,l
C56D: 2F      	  cpl
C56E: 6F      	  ld   l,a
C56F: C9      	  ret
              	; --------------------------------------
              	;             STRLEN
              	; --------------------------------------
C570:         	word_1072:
C570: CDC4C0  		call	CompileCallFollowing
C573: D5      	  push  de
C574: EB      	  ex   de,hl
C575: 210000  	  ld   hl,0
C578:         	_SLNLoop:
C578: 1A      	  ld   a,(de)
C579: B7      	  or   a
C57A: 2804    	  jr   z,_SLNExit
C57C: 13      	  inc  de
C57D: 23      	  inc  hl
C57E: 18F8    	  jr   _SLNLoop
C580:         	_SLNExit:
C580: D1      	  pop  de
C581: C9      	  ret
              	; --------------------------------------
              	;             RANDOM
              	; --------------------------------------
C582:         	word_1073:
C582: CDC4C0  		call	CompileCallFollowing
C585: EB      	 ex   de,hl
C586: C5      	 push  bc
C587: 2A3CC0  	    ld   hl,(seed1)
C58A: 44      	    ld   b,h
C58B: 4D      	    ld   c,l
C58C: 29      	    add  hl,hl
C58D: 29      	    add  hl,hl
C58E: 2C      	    inc  l
C58F: 09      	    add  hl,bc
C590: 223CC0  	    ld   (seed1),hl
C593: 2A3EC0  	    ld   hl,(seed2)
C596: 29      	    add  hl,hl
C597: 9F      	    sbc  a,a
C598: E62D    	    and  %00101101
C59A: AD      	    xor  l
C59B: 6F      	    ld   l,a
C59C: 223EC0  	    ld   (seed2),hl
C59F: 09      	    add  hl,bc
C5A0: C1      	    pop  bc
C5A1: C9      	    ret
              	; --------------------------------------
              	;             IM.DRAW
              	; --------------------------------------
C5A2:         	word_1074:
C5A2: CDC4C0  		call	CompileCallFollowing
C5A5: C5      	  push  bc
C5A6: D5      	  push  de
C5A7: E5      	  push  hl
              	
C5A8: 63      	  ld   h,e
C5A9: 6D      	  ld   l,l
              	
C5AA: 59      	  ld   e,c
C5AB: 50      	  ld   d,b
              	
C5AC: 010000  	  ld   bc,$0000
              	
C5AF: CD7CC6  	  call  ImageDraw
C5B2: E1      	  pop  hl
C5B3: D1      	  pop  de
C5B4: C1      	  pop  bc
C5B5: C9      	  ret
              	; --------------------------------------
              	;             IM.COLOUR
              	; --------------------------------------
C5B6:         	word_1075:
C5B6: CDC4C0  		call	CompileCallFollowing
C5B9: 7D      	  ld    a,l
C5BA: 3240C0  	  ld   (imageDefaultColour),a
C5BD: C9      	  ret
              	; --------------------------------------
              	;             SG.DRAW
              	; --------------------------------------
C5BE:         	word_1076:
C5BE: CDC4C0  		call	CompileCallFollowing
C5C1: C5      	  push  bc
C5C2: D5      	  push  de
C5C3: E5      	  push  hl
              	
              	
C5C4: 4E      	  ld   c,(hl)    ; count in BC
C5C5: 23      	  inc  hl
C5C6: 46      	  ld   b,(hl)
C5C7: 23      	  inc  hl
              	
C5C8:         	_SGDLoop:
C5C8: CDD7C6  	  call  CopySpriteData
C5CB: CD02C7  	  call  DrawOneSprite
C5CE: 23      	  inc  hl
C5CF: 23      	  inc  hl
C5D0: 0B      	  dec  bc
C5D1: 78      	  ld   a,b
C5D2: B1      	  or   c
C5D3: 20F3    	  jr   nz,_SGDLoop
              	
C5D5: E1      	  pop  hl
C5D6: D1      	  pop  de
C5D7: C1      	  pop  bc
C5D8: C9      	  ret
              	; --------------------------------------
              	;             SG.ERASE
              	; --------------------------------------
C5D9:         	word_1077:
C5D9: CDC4C0  		call	CompileCallFollowing
C5DC: C5      	  push  bc
C5DD: D5      	  push  de
C5DE: E5      	  push  hl
              	
C5DF: 3A40C0  	  ld   a,(imageDefaultColour)
C5E2: F5      	  push  af     ; save sprite default colour
C5E3: AF      	  xor  a      ; zero it, just in case we are restoring $00.
C5E4: 3240C0  	  ld   (imageDefaultColour),a
              	
C5E7: 4E      	  ld   c,(hl)    ; count in BC
C5E8: 23      	  inc  hl
C5E9: 46      	  ld   b,(hl)
C5EA: 2B      	  dec  hl
              	
C5EB: 09      	  add  hl,bc    ; advance to last.
C5EC: 09      	  add  hl,bc
C5ED:         	_SEDLoop:
C5ED: CD26C7  	  call  EraseOneSprite
C5F0: 2B      	  dec  hl
C5F1: 2B      	  dec  hl
C5F2: 0B      	  dec  bc
C5F3: 78      	  ld   a,b
C5F4: B1      	  or   c
C5F5: 20F6    	  jr   nz,_SEDLoop
              	
C5F7: F1      	  pop  af     ; restore default colour
C5F8: 3240C0  	  ld   (imageDefaultColour),a
              	
C5FB: E1      	  pop  hl
C5FC: D1      	  pop  de
C5FD: C1      	  pop  bc
C5FE: C9      	  ret
              	
              	
              	
C5FF:         	DIVDivideMod16:
C5FF: C5      	 push  bc
C600: 42      	 ld   b,d     ; DE
C601: 4B      	 ld   c,e
C602: EB      	 ex   de,hl
C603: 210000  	 ld   hl,0
C606: 78      	 ld   a,b
C607: 0608    	 ld   b,8
C609:         	Div16_Loop1:
C609: 17      	 rla
C60A: ED6A    	 adc  hl,hl
C60C: ED52    	 sbc  hl,de
C60E: 3001    	 jr   nc,Div16_NoAdd1
C610: 19      	 add  hl,de
C611:         	Div16_NoAdd1:
C611: 10F6    	 djnz  Div16_Loop1
C613: 17      	 rla
C614: 2F      	 cpl
C615: 47      	 ld   b,a
C616: 79      	 ld   a,c
C617: 48      	 ld   c,b
C618: 0608    	 ld   b,8
C61A:         	Div16_Loop2:
C61A: 17      	 rla
C61B: ED6A    	 adc  hl,hl
C61D: ED52    	 sbc  hl,de
C61F: 3001    	 jr   nc,Div16_NoAdd2
C621: 19      	 add  hl,de
C622:         	Div16_NoAdd2:
C622: 10F6    	 djnz  Div16_Loop2
C624: 17      	 rla
C625: 2F      	 cpl
C626: 51      	 ld   d,c
C627: 5F      	 ld   e,a
C628: C1      	 pop  bc
C629: C9      	 ret
C62A:         	MULTMultiply16:
C62A: C5      	  push  bc
C62B: D5      	  push  de
C62C: 44      	  ld   b,h        ; get multipliers in DE/BC
C62D: 4D      	  ld   c,l
C62E: 210000  	  ld   hl,0        ; zero total
C631:         	__Core__Mult_Loop:
C631: CB41    	  bit  0,c        ; lsb of shifter is non-zero
C633: 2801    	  jr   z,__Core__Mult_Shift
C635: 19      	  add  hl,de        ; add adder to total
C636:         	__Core__Mult_Shift:
C636: CB38    	  srl  b         ; shift BC right.
C638: CB19    	  rr   c
C63A: EB      	  ex   de,hl        ; shift DE left
C63B: 29      	  add  hl,hl
C63C: EB      	  ex   de,hl
C63D: 78      	  ld   a,b        ; loop back if BC is nonzero
C63E: B1      	  or   c
C63F: 20F0    	  jr   nz,__Core__Mult_Loop
C641: D1      	  pop  de
C642: C1      	  pop  bc
C643: C9      	  ret
C644:         	ConstantHandler:
C644: 3EEB    	  ld   a,0xEB       ; compile ex de,hl
C646: CDDDC0  	  call  CompileByte
C649: 3E21    	  ld   a,0x21       ; compile ld hl,
C64B: CDDDC0  	  call  CompileByte
C64E: E1      	  pop  hl        ; address of word to compile
C64F: 7E      	  ld   a,(hl)
C650: 23      	  inc  hl
C651: 66      	  ld   h,(hl)
C652: 6F      	  ld   l,a
C653: CDCEC0  	  call  CompileWord     ; compile that word.
C656: C9      	  ret
              	
              	
C657:         	VariableHandler:
C657: 3EEB    	  ld   a,0xEB       ; compile ex de,hl
C659: CDDDC0  	  call  CompileByte
C65C: 3E21    	  ld   a,0x21       ; compile ld hl,
C65E: CDDDC0  	  call  CompileByte
C661: E1      	  pop  hl        ; address of word to compile
C662: CDCEC0  	  call  CompileWord     ; compile that word.
C665: C9      	  ret
              	
              	
C666:         	FixAccessCodeWrite:
C666: 3E2A    	  ld   a,0x2A       ; LD HL,(xxxx)
C668: 3002    	  jr   nc,_FACIsRead     ; use Carry to decide what to update
C66A: 3E22    	  ld   a,0x22
C66C:         	_FACIsRead:
              	  ;
C66C: 2A12C0  	  ld   hl,(CodeNextFree)    ; we save one byte.
C66F: 2B      	  dec  hl
C670: 2212C0  	  ld   (CodeNextFree),hl
              	  ;
C673: 46      	  ld   b,(hl)
C674: 2B      	  dec  hl
C675: 4E      	  ld   c,(hl)
C676: 70      	  ld   (hl),b
C677: 2B      	  dec  hl
C678: 71      	  ld   (hl),c
C679: 2B      	  dec  hl
C67A: 77      	  ld   (hl),a
C67B: C9      	  ret
C67C:         	ImageDraw:
C67C: 7D      	  ld  a,l       ; check in range 0..39 0..23
C67D: FE18    	  cp   24
C67F: D0      	  ret  nc
C680: 7C      	  ld   a,h
C681: FE28    	  cp   40
C683: D0      	  ret  nc
              	
C684: CDC1C6  	  call  IDCalculatePos     ; calculate position on screen -> HL
              	
C687: 1A      	  ld   a,(de)       ; get X,Y size into A
C688: 13      	  inc  de        ; advance into graphic data
              	
C689: 02      	  ld   (bc),a       ; write size out to save, so it's a graphic
C68A: 03      	  inc  bc        ; in its own right.
              	  ;
              	  ;   Draw one line A is size, HL screen pos, DE gfx data, BC store.
              	  ;
C68B:         	_IDOuter:
C68B: F5      	  push  af        ; save height counter.
C68C: E5      	  push  hl        ; save screen position, start of line
C68D: E60F    	  and  $0F       ; make A a horizontal counter, e.g. 0..15
C68F: 281A    	  jr   z,_IDDoneBoth     ; width zero, nothing to do.
C691:         	_IDInner:
              	  ;
              	  ;   Save/Copy one byte, go through this twice, once for colour RAM $3000-$33FF and once
              	  ;   for char RAM $3400-$37FF
              	  ;
C691: F5      	  push  af        ; save A
              	
C692: 7E      	  ld   a,(hl)       ; get and save old value
C693: 02      	  ld   (bc),a
C694: 03      	  inc  bc
              	
C695: 1A      	  ld   a,(de)       ; copy out new value
C696: B7      	  or   a        ; zero ?
C697: 2007    	  jr   nz,_IDNotDefault    ; can't be default
C699: CB54    	  bit  2,h       ; in char RAM, can't be default
C69B: 2803    	  jr   z,_IDNotDefault
C69D: 3A40C0  	  ld   a,(imageDefaultColour)  ; load default colour
C6A0:         	_IDNotDefault:
C6A0: 77      	  ld   (hl),a
C6A1: 13      	  inc  de
              	
C6A2: F1      	  pop  af        ; restore A
              	
C6A3: CB54    	  bit  2,h       ; are we in $34xx e.g. have just written to colour RAM
C6A5: 2004    	  jr   nz,_IDDoneBoth     ; if so we've done both.
C6A7: CBD4    	  set  2,h       ; otherwise do the colour RAM copy
C6A9: 18E6    	  jr   _IDInner
              	  ;
              	  ;   Done one character, now advance one right.
              	  ;
C6AB:         	_IDDoneBoth:
C6AB: CB94    	  res  2,h       ; back to character RAM.
C6AD: 23      	  inc  hl        ; next character to the right
C6AE: 3D      	  dec  a        ; done the lot
C6AF: 20E0    	  jr   nz,_IDInner      ; no, go back.
              	
C6B1: E1      	  pop  hl        ; restore start of line
C6B2: 7D      	  ld   a,l       ; go down one line
C6B3: C628    	  add  a,40
C6B5: 6F      	  ld   l,a
C6B6: 3001    	  jr   nc,_IDNoCarry
C6B8: 24      	  inc  h
C6B9:         	_IDNoCarry:
C6B9: F1      	  pop  af        ; restore line counter
C6BA: D610    	  sub  a,$10       ; decrement the upper nibble of the counter
C6BC: FE10    	  cp   a,$10       ; until upper nibble is $00
C6BE: 30CB    	  jr   nc,_IDOuter
              	
C6C0: C9      	  ret
C6C1:         	IDCalculatePos:
C6C1: D5      	  push  de
C6C2: 7C      	  ld   a,h       ; save X in A
C6C3: 2600    	  ld   h,0       ; HL = Y
              	
C6C5: 29      	  add  hl,hl       ; HL = Y x 8
C6C6: 29      	  add  hl,hl
C6C7: 29      	  add  hl,hl
C6C8: 5D      	  ld   e,l       ; DE = Y x 8
C6C9: 54      	  ld  d,h
C6CA: 29      	  add  hl,hl       ; HL = Y x 32
C6CB: 29      	  add  hl,hl
C6CC: 19      	  add  hl,de       ; HL = Y x 40
              	
C6CD: 5F      	  ld   e,a       ; DE = X
C6CE: 1600    	  ld   d,0
C6D0: 19      	  add  hl,de       ; HL = X + Y x 40
              	
C6D1: 112830  	  ld   de,$3028      ; now a screen position
C6D4: 19      	  add  hl,de
              	
C6D5: D1      	  pop  de
C6D6: C9      	  ret
C6D7:         	CopySpriteData:
C6D7: C5      	  push  bc
C6D8: D5      	  push  de
C6D9: E5      	  push  hl
C6DA: 7E      	  ld   a,(hl)       ; point to sprite in HL and DE
C6DB: 23      	  inc  hl
C6DC: 66      	  ld   h,(hl)
C6DD: 6F      	  ld   l,a
C6DE: 5D      	  ld   e,l
C6DF: 54      	  ld   d,h
C6E0: 010600  	  ld   bc,6       ; HL points to the values, DE to the update values.
C6E3: 09      	  add  hl,bc
C6E4: EB      	  ex   de,hl       ; HL is the update values, DE the target values.
C6E5: 0603    	  ld   b,3       ; update potentially three values
C6E7:         	_CSDLoop:
C6E7: 7E      	  ld   a,(hl)       ; check HL points to $FFFF
C6E8: 23      	  inc  hl
C6E9: A6      	  and  (hl)
C6EA: 3C      	  inc  a        ; zero if was $FF
C6EB: 280C    	  jr   z,_CSDNext
              	
C6ED: 2B      	  dec  hl        ; HL/DE are first byte
C6EE: 7E      	  ld   a,(hl)
C6EF: 12      	  ld   (de),a
C6F0: 36FF    	  ld   (hl),$FF
C6F2: 13      	  inc  de        ; second byte
C6F3: 23      	  inc  hl
C6F4: 7E      	  ld   a,(hl)
C6F5: 12      	  ld   (de),a
C6F6: 36FF    	  ld   (hl),$FF
C6F8: 1B      	  dec  de        ; fix so both increments +2
C6F9:         	_CSDNext:
C6F9: 13      	  inc  de
C6FA: 13      	  inc  de
C6FB: 23      	  inc  hl
C6FC: 10E9    	  djnz  _CSDLoop
              	
C6FE: E1      	  pop  hl
C6FF: D1      	  pop  de
C700: C1      	  pop  bc
C701: C9      	  ret
              	
              	
C702:         	DrawOneSprite:
C702: C5      	  push  bc
C703: D5      	  push  de
C704: E5      	  push  hl
              	
C705: 7E      	  ld   a,(hl)       ; point to sprite in HL and BC
C706: 23      	  inc  hl
C707: 66      	  ld   h,(hl)
C708: 6F      	  ld   l,a
              	
C709: 010C00  	  ld   bc,12       ; point to storage space HL
C70C: 09      	  add  hl,bc
              	
C70D: 44      	  ld   b,h       ; storage space in BC.
C70E: 4D      	  ld   c,l
              	
C70F: 2B      	  dec  hl        ; graphic address in DE.
C710: 56      	  ld   d,(hl)
C711: 2B      	  dec  hl
C712: 5E      	  ld   e,(hl)
              	
C713: 7A      	  ld   a,d       ; if $FFFF do
C714: A3      	  and  e
C715: 3C      	  inc  a
C716: 280A    	  jr   z,_DOSExit
              	
C718: 2B      	  dec  hl        ; Y in A
C719: 2B      	  dec  hl
C71A: 7E      	  ld   a,(hl)
C71B: 2B      	  dec  hl        ; X in L
C71C: 2B      	  dec  hl
C71D: 66      	  ld   h,(hl)
C71E: 6F      	  ld   l,a       ; HL = (X,Y)
              	
C71F: CD7CC6  	  call  ImageDraw      ; draw the image copying the background
              	
C722:         	_DOSExit:
C722: E1      	  pop  hl
C723: D1      	  pop  de
C724: C1      	  pop  bc
C725: C9      	  ret
              	
              	
C726:         	EraseOneSprite:
C726: C5      	  push  bc
C727: D5      	  push  de
C728: E5      	  push  hl
              	
              	
C729: 7E      	  ld   a,(hl)       ; point to sprite in HL and DE
C72A: 23      	  inc  hl
C72B: 66      	  ld   h,(hl)
C72C: 6F      	  ld   l,a
              	
C72D: 010C00  	  ld   bc,12       ; point to storage space.
C730: 09      	  add  hl,bc
              	
C731: 54      	  ld   d,h       ; storage space in DE, drawing fom here
C732: 5D      	  ld   e,l
              	
C733: 010000  	  ld   bc,$0000      ; copy data to ROM.
              	
C736: 2B      	  dec  hl        ; if graphic is $FFFF do nothing.
C737: 7E      	  ld   a,(hl)
C738: 2B      	  dec  hl
C739: A6      	  and  (hl)
C73A: 3C      	  inc  a
C73B: 280A    	  jr   z,_EOSExit
              	
C73D: 2B      	  dec  hl        ; Y in A
C73E: 2B      	  dec  hl
C73F: 7E      	  ld   a,(hl)
C740: 2B      	  dec  hl        ; X in L
C741: 2B      	  dec  hl
C742: 66      	  ld   h,(hl)
C743: 6F      	  ld   l,a       ; HL = (X,Y)
              	
C744: CD7CC6  	  call  ImageDraw      ; draw the image copying the background
              	
C747:         	_EOSExit:
C747: E1      	  pop  hl
C748: D1      	  pop  de
C749: C1      	  pop  bc
C74A: C9      	  ret
C74B:         	FreeSpace:
              	
              	; ***************************************************************************************
              	;
              	;										ROM Header
              	;
              	; ***************************************************************************************
              	
C74B: FFFFFFFF		.org	$E000
C74F: FF...   	
E000: 50535200		.db  	"PSR",0 						; 4 bytes filler.
E004: 009C00B0		.db  	0,$9C,0,$B0,0,$6C 				; 12 bytes ROM Identify
E008: 006C    	
E00A: 006400A8		.db 	0,$64,0,$A8,$5F,$70 			; the $5F makes the total $70 so $00 is output to scrambler
E00E: 5F70    	
              		.org 	$E010
E010: C300C0  		jp 		start 							; BIOS enters here.
              	
              	; ***************************************************************************************
              	;
              	; 				Load the Dictionary into High memory, it works down.
              	;
              	; ***************************************************************************************
              	
              		.include "vocabulary/dictionary.inc" 	; get length
020A:         	DictionarySize = 522
E013: FFFFFFFF		.org 	CodeEnd-DictionarySize+1 		; set start pointer
E017: FF...   	
FDF6:         	DictionaryInstalledBase:
              		.include "vocabulary/dictionary.asm" 	; pregenerated dictionary.
              	; <
FDF6: 80      		.db	$80
FDF7: D8C2    		.dw	word_1000
FDF9: BC      		.db	$bc
              	; =
FDFA: 80      		.db	$80
FDFB: F0C2    		.dw	word_1001
FDFD: BD      		.db	$bd
              	; -
FDFE: 80      		.db	$80
FDFF: FFC2    		.dw	word_1002
FE01: AD      		.db	$ad
              	; +
FE02: 80      		.db	$80
FE03: 09C3    		.dw	word_1003
FE05: AB      		.db	$ab
              	; AND
FE06: 80      		.db	$80
FE07: 0EC3    		.dw	word_1004
FE09: 010E84  		.db	$1,$e,$84
              	; OR
FE0C: 80      		.db	$80
FE0D: 18C3    		.dw	word_1005
FE0F: 0F92    		.db	$f,$92
              	; XOR
FE11: 80      		.db	$80
FE12: 22C3    		.dw	word_1006
FE14: 180F92  		.db	$18,$f,$92
              	; /
FE17: 80      		.db	$80
FE18: 2CC3    		.dw	word_1007
FE1A: AF      		.db	$af
              	; MOD
FE1B: 80      		.db	$80
FE1C: 36C3    		.dw	word_1008
FE1E: 0D0F84  		.db	$d,$f,$84
              	; !
FE21: 80      		.db	$80
FE22: 3FC3    		.dw	word_1009
FE24: A1      		.db	$a1
              	; @
FE25: 80      		.db	$80
FE26: 47C3    		.dw	word_1010
FE28: 80      		.db	$80
              	; +!
FE29: 80      		.db	$80
FE2A: 4FC3    		.dw	word_1011
FE2C: 2BA1    		.db	$2b,$a1
              	; C!
FE2E: 80      		.db	$80
FE2F: 5BC3    		.dw	word_1012
FE31: 03A1    		.db	$3,$a1
              	; C@
FE33: 80      		.db	$80
FE34: 60C3    		.dw	word_1013
FE36: 0380    		.db	$3,$80
              	; P@
FE38: 80      		.db	$80
FE39: 67C3    		.dw	word_1014
FE3B: 1080    		.db	$10,$80
              	; P!
FE3D: 80      		.db	$80
FE3E: 73C3    		.dw	word_1015
FE40: 10A1    		.db	$10,$a1
              	; ,
FE42: 80      		.db	$80
FE43: 80C3    		.dw	word_1016
FE45: AC      		.db	$ac
              	; ;
FE46: 81      		.db	$81
FE47: 86C3    		.dw	word_1017
FE49: BB      		.db	$bb
              	; C,
FE4A: 80      		.db	$80
FE4B: 8CC3    		.dw	word_1018
FE4D: 03AC    		.db	$3,$ac
              	; COPY
FE4F: 80      		.db	$80
FE50: 93C3    		.dw	word_1019
FE52: 030F1099		.db	$3,$f,$10,$99
              	; FILL
FE56: 80      		.db	$80
FE57: B3C3    		.dw	word_1020
FE59: 06090C8C		.db	$6,$9,$c,$8c
              	; HALT
FE5D: 80      		.db	$80
FE5E: C6C3    		.dw	word_1021
FE60: 08010C94		.db	$8,$1,$c,$94
              	; BREAK
FE64: 80      		.db	$80
FE65: CDC3    		.dw	word_1022
FE67: 02120501		.db	$2,$12,$5,$1,$8b
FE6B: 8B      	
              	; *
FE6C: 80      		.db	$80
FE6D: D2C3    		.dw	word_1023
FE6F: AA      		.db	$aa
              	; SWAP
FE70: 80      		.db	$80
FE71: D8C3    		.dw	word_1024
FE73: 13170190		.db	$13,$17,$1,$90
              	; A>B
FE77: 80      		.db	$80
FE78: DDC3    		.dw	word_1025
FE7A: 013E82  		.db	$1,$3e,$82
              	; A>C
FE7D: 80      		.db	$80
FE7E: E3C3    		.dw	word_1026
FE80: 013E83  		.db	$1,$3e,$83
              	; B>A
FE83: 80      		.db	$80
FE84: E9C3    		.dw	word_1027
FE86: 023E81  		.db	$2,$3e,$81
              	; B>C
FE89: 80      		.db	$80
FE8A: EFC3    		.dw	word_1028
FE8C: 023E83  		.db	$2,$3e,$83
              	; C>A
FE8F: 80      		.db	$80
FE90: F5C3    		.dw	word_1029
FE92: 033E81  		.db	$3,$3e,$81
              	; C>B
FE95: 80      		.db	$80
FE96: FBC3    		.dw	word_1030
FE98: 033E82  		.db	$3,$3e,$82
              	; PUSH
FE9B: 81      		.db	$81
FE9C: 01C4    		.dw	word_1031
FE9E: 10151388		.db	$10,$15,$13,$88
              	; POP
FEA2: 81      		.db	$81
FEA3: 06C4    		.dw	word_1032
FEA5: 100F90  		.db	$10,$f,$90
              	; A>R
FEA8: 81      		.db	$81
FEA9: 0CC4    		.dw	word_1033
FEAB: 013E92  		.db	$1,$3e,$92
              	; R>A
FEAE: 81      		.db	$81
FEAF: 11C4    		.dw	word_1034
FEB1: 123E81  		.db	$12,$3e,$81
              	; B>R
FEB4: 81      		.db	$81
FEB5: 16C4    		.dw	word_1035
FEB7: 023E92  		.db	$2,$3e,$92
              	; R>B
FEBA: 81      		.db	$81
FEBB: 1BC4    		.dw	word_1036
FEBD: 123E82  		.db	$12,$3e,$82
              	; C>R
FEC0: 81      		.db	$81
FEC1: 20C4    		.dw	word_1037
FEC3: 033E92  		.db	$3,$3e,$92
              	; R>C
FEC6: 81      		.db	$81
FEC7: 25C4    		.dw	word_1038
FEC9: 123E83  		.db	$12,$3e,$83
              	; AB>R
FECC: 81      		.db	$81
FECD: 2AC4    		.dw	word_1039
FECF: 01023E92		.db	$1,$2,$3e,$92
              	; R>AB
FED3: 81      		.db	$81
FED4: 30C4    		.dw	word_1040
FED6: 123E0182		.db	$12,$3e,$1,$82
              	; ABC>R
FEDA: 81      		.db	$81
FEDB: 36C4    		.dw	word_1041
FEDD: 0102033E		.db	$1,$2,$3,$3e,$92
FEE1: 92      	
              	; R>ABC
FEE2: 81      		.db	$81
FEE3: 3DC4    		.dw	word_1042
FEE5: 123E0102		.db	$12,$3e,$1,$2,$83
FEE9: 83      	
              	; H
FEEA: 80      		.db	$80
FEEB: 44C4    		.dw	word_1043
FEED: 88      		.db	$88
              	; $SYSTEM
FEEE: 80      		.db	$80
FEEF: 4CC4    		.dw	word_1044
FEF1: 24131913		.db	$24,$13,$19,$13,$14,$5,$8d
FEF5: 14058D  	
              	; $DICTIONARY
FEF8: 80      		.db	$80
FEF9: 54C4    		.dw	word_1045
FEFB: 24040903		.db	$24,$4,$9,$3,$14,$9,$f,$e,$1,$12,$99
FEFF: 14090F0E	
FF03: 011299  	
              	; WARM.START
FF06: 80      		.db	$80
FF07: 5CC4    		.dw	word_1046
FF09: 1701120D		.db	$17,$1,$12,$d,$2e,$13,$14,$1,$12,$94
FF0D: 2E131401	
FF11: 1294    	
              	; REPORT.ERROR
FF13: 80      		.db	$80
FF14: 62C4    		.dw	word_1047
FF16: 1205100F		.db	$12,$5,$10,$f,$12,$14,$2e,$5,$12,$12,$f,$92
FF1A: 12142E05	
FF1E: 12120F92	
              	; $COMPILER
FF22: 80      		.db	$80
FF23: 68C4    		.dw	word_1048
FF25: 24030F0D		.db	$24,$3,$f,$d,$10,$9,$c,$5,$92
FF29: 10090C05	
FF2D: 92      	
              	; CONSTANT
FF2E: 80      		.db	$80
FF2F: 6EC4    		.dw	word_1049
FF31: 030F0E13		.db	$3,$f,$e,$13,$14,$1,$e,$94
FF35: 14010E94	
              	; VARIABLE
FF39: 80      		.db	$80
FF3A: 83C4    		.dw	word_1050
FF3C: 16011209		.db	$16,$1,$12,$9,$1,$2,$c,$85
FF40: 01020C85	
              	; DATA
FF44: 80      		.db	$80
FF45: 98C4    		.dw	word_1051
FF47: 04011481		.db	$4,$1,$14,$81
              	; ARRAY
FF4B: 80      		.db	$80
FF4C: A7C4    		.dw	word_1052
FF4E: 01121201		.db	$1,$12,$12,$1,$99
FF52: 99      	
              	; ADDRESS.OF
FF53: 80      		.db	$80
FF54: C3C4    		.dw	word_1053
FF56: 01040412		.db	$1,$4,$4,$12,$5,$13,$13,$2e,$f,$86
FF5A: 0513132E	
FF5E: 0F86    	
              	; !!
FF60: 81      		.db	$81
FF61: D7C4    		.dw	word_1054
FF63: 21A1    		.db	$21,$a1
              	; @@
FF65: 81      		.db	$81
FF66: E8C4    		.dw	word_1055
FF68: 0080    		.db	$0,$80
              	; ---
FF6A: 80      		.db	$80
FF6B: F1C4    		.dw	word_1056
FF6D: 2D2DAD  		.db	$2d,$2d,$ad
              	; --
FF70: 80      		.db	$80
FF71: F7C4    		.dw	word_1057
FF73: 2DAD    		.db	$2d,$ad
              	; ++
FF75: 80      		.db	$80
FF76: FCC4    		.dw	word_1058
FF78: 2BAB    		.db	$2b,$ab
              	; +++
FF7A: 80      		.db	$80
FF7B: 01C5    		.dw	word_1059
FF7D: 2B2BAB  		.db	$2b,$2b,$ab
              	; 0-
FF80: 80      		.db	$80
FF81: 07C5    		.dw	word_1060
FF83: 30AD    		.db	$30,$ad
              	; 0<
FF85: 80      		.db	$80
FF86: 12C5    		.dw	word_1061
FF88: 30BC    		.db	$30,$bc
              	; 0=
FF8A: 80      		.db	$80
FF8B: 1DC5    		.dw	word_1062
FF8D: 30BD    		.db	$30,$bd
              	; 2*
FF8F: 80      		.db	$80
FF90: 28C5    		.dw	word_1063
FF92: 32AA    		.db	$32,$aa
              	; 4*
FF94: 80      		.db	$80
FF95: 2DC5    		.dw	word_1064
FF97: 34AA    		.db	$34,$aa
              	; 8*
FF99: 80      		.db	$80
FF9A: 33C5    		.dw	word_1065
FF9C: 38AA    		.db	$38,$aa
              	; 16*
FF9E: 80      		.db	$80
FF9F: 3AC5    		.dw	word_1066
FFA1: 3136AA  		.db	$31,$36,$aa
              	; 2/
FFA4: 80      		.db	$80
FFA5: 42C5    		.dw	word_1067
FFA7: 32AF    		.db	$32,$af
              	; 4/
FFA9: 80      		.db	$80
FFAA: 4AC5    		.dw	word_1068
FFAC: 34AF    		.db	$34,$af
              	; ABS
FFAE: 80      		.db	$80
FFAF: 56C5    		.dw	word_1069
FFB1: 010293  		.db	$1,$2,$93
              	; BSWAP
FFB4: 80      		.db	$80
FFB5: 5FC5    		.dw	word_1070
FFB7: 02131701		.db	$2,$13,$17,$1,$90
FFBB: 90      	
              	; NOT
FFBC: 80      		.db	$80
FFBD: 66C5    		.dw	word_1071
FFBF: 0E0F94  		.db	$e,$f,$94
              	; STRLEN
FFC2: 80      		.db	$80
FFC3: 70C5    		.dw	word_1072
FFC5: 1314120C		.db	$13,$14,$12,$c,$5,$8e
FFC9: 058E    	
              	; RANDOM
FFCB: 80      		.db	$80
FFCC: 82C5    		.dw	word_1073
FFCE: 12010E04		.db	$12,$1,$e,$4,$f,$8d
FFD2: 0F8D    	
              	; IM.DRAW
FFD4: 80      		.db	$80
FFD5: A2C5    		.dw	word_1074
FFD7: 090D2E04		.db	$9,$d,$2e,$4,$12,$1,$97
FFDB: 120197  	
              	; IM.COLOUR
FFDE: 80      		.db	$80
FFDF: B6C5    		.dw	word_1075
FFE1: 090D2E03		.db	$9,$d,$2e,$3,$f,$c,$f,$15,$92
FFE5: 0F0C0F15	
FFE9: 92      	
              	; SG.DRAW
FFEA: 80      		.db	$80
FFEB: BEC5    		.dw	word_1076
FFED: 13072E04		.db	$13,$7,$2e,$4,$12,$1,$97
FFF1: 120197  	
              	; SG.ERASE
FFF4: 80      		.db	$80
FFF5: D9C5    		.dw	word_1077
FFF7: 13072E05		.db	$13,$7,$2e,$5,$12,$1,$13,$85
FFFB: 12011385	
FFFF: 00      		.db	$00


total time: 0.0072 sec.
no errors
