              	; --------------------------------------
              	; zasm: assemble "m7.asm"
              	; date: 2021-10-16 12:43:53
              	; --------------------------------------


              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		m7.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		15th October 2021
              	;		Purpose :	M7 Main.
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
C000:         	CodeStart = 0xC000
FFFF:         	CodeEnd = 0xFFFF
              	
C000:         		.org CodeStart
              	
              	; ***************************************************************************************
              	;
              	; 									  Code Header
              	;
              	; ***************************************************************************************
              	
C000:         	start: 								
C000: ED7B1CC0		ld 		sp,(StackPointer) 				; have a workable stack
C004: 2A20C0  		ld 		hl,(StartAddress) 				; running from here
C007: E9      		jp 		(hl) 							
              	
C008: FFFFFFFF		.org 	start+16 						; information area
C00C: FFFFFFFF	
C010: 00C0    		.word 	start 							; +$10 base address of kernel
C012: 1CC0    		.word 	DataArea  						; +$12 address of data area.
C014: 3DC0    		.word	CopyFollowing  					; +$14 utility function addresses
C016: 4AC0    		.word	CompileCallFollowing
C018: 54C0    		.word	CompileWord
C01A: 63C0    		.word	CompileByte
              	
              		.include "data.asm" 					; data area.
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		data.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		15th October 2021
              	;		Purpose :	Data 
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	
              	; ***************************************************************************************
              	;
              	;										Data Area
              	;
              	; ***************************************************************************************
              	
C01C:         	DataArea:
              	;
              	; 		Initial Stack Pointer
              	;
C01C:         	StackPointer:
C01C: FF3F    		.dw 	$3FFF
              	;
              	; 		Next free code byte
              	;
C01E:         	CodeNextFree:
C01E: 82C4    		.dw 	FreeSpace
              	;
              	; 		Execute address for startup
              	;
C020:         	StartAddress:	
C020: 2AC0    		.dw 	Main
              	;
              	; 		Dictionary start (works down)
              	;
C022:         	DictionaryBase:
C022: AFFE    		.dw 	DictionaryInstalledBase
              	;
              	; 		Current state of the 3 registers
              	;
C024:         	RegA:
C024: 0000    		.dw 	$0000
C026:         	RegB:
C026: 0000    		.dw 	$0000
C028:         	RegC:
C028: 0000    		.dw 	$0000
              		.include "kernel/kernel.asm"			; kernel code.	
C02A:         	Main:
C02A: 2113E0  		ld 		hl,testCode
C02D: CD6EC0  		call 	CompileStream
              	
C030:         	WarmStart:
C030: ED7B1CC0		ld 		sp,(StackPointer)
C034: C330C0  		jp 		WarmStart	
              	
C037:         	WordIsCompileOnly:
C037: 76      		halt
C038: 18FD    		jr 		WordIsCompileOnly
              	
C03A:         	UnknownWord:
C03A: 76      		halt
C03B: 18FD    		jr 		UnknownWord
              	
              		.include 	"code.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		code.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		15th October 2021
              	;		Purpose :	Miscellaneous words
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	; 		Copy the code following (length byte first) then pop to previous level.
              	;
              	; ***************************************************************************************
              	
C03D:         	CopyFollowing:
C03D: E3      			ex 		(sp),hl  			 		; old HL saved on stack, HL contains length pointer
C03E: C5      			push 	bc 							; save BC
C03F: 46      			ld 		b,(hl) 						; get count to copy
C040:         	_CopyFollowing:
C040: 23      			inc 	hl 							; get next to copy
C041: 7E      			ld 		a,(hl)
C042: CD63C0  			call 	CompileByte 				; and compile it.
C045: 10F9    			djnz 	_CopyFollowing 				; copy that many bytes.	
C047: C1      			pop 	bc 							; restore BC, HL
C048: E1      			pop 	hl 
C049: C9      			ret 								; return to the previous level.
              	
              	; ***************************************************************************************
              	;
              	; 							Compile call to following code
              	;
              	; ***************************************************************************************
              	
C04A:         	CompileCallFollowing:
C04A: 3ECD    			ld 		a,$CD 						; CD is Z80 "CALL" 
C04C: CD63C0  			call 	CompileByte
C04F: E1      			pop 	hl 							; get address to compile call to
C050: CD54C0  			call 	CompileWord
C053: C9      			ret 								; return to the previous level.
              	
              	; ***************************************************************************************
              	;
              	;									Compile HL to Code Space
              	;
              	; ***************************************************************************************
              	
C054:         	CompileWord:
C054: EB      			ex 		de,hl 						; DE contains value
C055: E5      			push 	hl 							; save HL
C056: 2A1EC0  			ld 		hl,(CodeNextFree) 			; get code address
C059: 73      			ld 		(hl),e 						; write out
C05A: 23      			inc 	hl 
C05B: 72      			ld 		(hl),d
C05C: 23      			inc 	hl
C05D: 221EC0  			ld 		(CodeNextFree),hl 			; update code address
C060: E1      			pop 	hl 							; restore HL, DE
C061: EB      			ex 		de,hl 							
C062: C9      			ret
              	
              	; ***************************************************************************************
              	;
              	;									Compile A to Code Space
              	;
              	; ***************************************************************************************
              	
C063:         	CompileByte:
C063: E5      			push 	hl 							; save HL, get code address
C064: 2A1EC0  			ld 		hl,(CodeNextFree)
C067: 77      			ld 		(hl),a  					; write out
C068: 23      			inc 	hl 							; bump & write back
C069: 221EC0  			ld 		(CodeNextFree),hl
C06C: E1      			pop 	hl 	
C06D: C9      			ret
              		.include 	"compiler.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		compiler.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		16th October 2021
              	;		Purpose :	Compile stream defining executing or compiling words 
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	; 	Compile stream at HL, executing, compiling or defining words according to their 
              	; 	colour. This is not re-entrant, as it exits to the warm start unless it goes to 
              	; 	compile something else.
              	;
              	; ***************************************************************************************
              	
C06E:         	CompileStream:
C06E: 7E      			ld 		a,(hl) 						; get next character
C06F: B7      			or 		a 							; if zero, warm start as end of stream
C070: CA30C0  			jp 		z,WarmStart
C073: 23      			inc 	hl 							; increment in case it is space
C074: E63F    			and 	$3F 						; check it is a coloured space.
C076: FE20    			cp 		$20
C078: 28F4    			jr 		z,CompileStream 			; if so go back
C07A: 2B      			dec 	hl 							; undo the get, so points to the non space non zero byte.
C07B: CD8BC0  			call 	CompileOne 					; compile word at HL.
              			;
C07E:         	_CSNext:		
C07E: 7E      			ld 		a,(hl) 						; advance forward to next word
C07F: B7      			or 		a 							; if found $00 end of stream go back to CompileStream
C080: 28EC    			jr 		z,CompileStream
C082: 23      			inc 	hl
C083: E63F    			and 	#$3F 						; check for colour space
C085: FE20    			cp 		$20
C087: 20F5    			jr 		nz,_CSNext
C089: 18E3    			jr 		CompileStream 				; once found, try the next word.
              	
              	; ***************************************************************************************
              	;
              	; 						  Compile/Execute/Define word at HL.
              	;
              	; ***************************************************************************************
              	
C08B:         	CompileOne:
C08B: 7E      			ld 		a,(hl) 						; get the word's colour.
C08C: E6C0    			and 	$C0
C08E: C8      			ret  	z 							; exit immediately if it's a comment word.
C08F: E5      			push 	hl 							; save HL on stack
              	
C090: FEC0    			cp 		$C0 						; $40 and $80 , compile or execute, handled together
C092: 203B    			jr 		nz,_COExecuteCompile
              			;
              			; 		Create a new definition using the word at HL.
              			;
C094: 06FF    			ld 		b,$FF 						; we write it out backwards so go forward counting characters. We count the space so -1 here.
C096:         	_CDFindEnd:
C096: 04      			inc 	b 							; bump count
C097: 7E      			ld 		a,(hl) 						; get character		
C098: 23      			inc 	hl
C099: B7      			or 		a
C09A: 2806    			jr 		z,_CDFoundEnd		 		; if zero, we're at the end
C09C: E63F    			and 	$3F
C09E: FE20    			cp 		$20
C0A0: 20F4    			jr 		nz,_CDFindEnd
C0A2:         	_CDFoundEnd:
              			;
              			; 		HL points one after the word end seperator, B is the count. C is the OR value for copying, which is only set 
              			; 		first time to $80
C0A2: 0E80    			ld 		c,$80 						; the copy OR value
C0A4: 2B      			dec 	hl 							; undo the get after getting the space.
C0A5:         	_CDCopyDictionary:
C0A5: 2B      			dec 	hl 							; get previous character. we are writing out backwards as we go down
C0A6: 7E      			ld 		a,(hl)
C0A7: E63F    			and 	$3F 						; colour dropped. (should be red)
C0A9: B1      			or 		c  							; OR C in, first time $80
C0AA: 0E00    			ld 		c,0 						; and next times it's only $00		
C0AC: CD9AC1  			call	CompileWriteDictionary 
C0AF: 10F4    			djnz 	_CDCopyDictionary 			; write out the whole word.
              			;
              			; 		Now create the rest of the record, the code address then type byte.
              			;
C0B1: 3A1FC0  			ld 		a,(CodeNextFree+1) 			; write out code MSB then LSB
C0B4: CD9AC1  			call	CompileWriteDictionary 
C0B7: 3A1EC0  			ld 		a,(CodeNextFree)
C0BA: CD9AC1  			call	CompileWriteDictionary 
C0BD: 3E80    			ld 		a,$80 						; then the default type byte
C0BF: CD9AC1  			call	CompileWriteDictionary 
              	
C0C2: 3ECD    			ld 		a,$CD 						; compile CALL CompileCallFollowing into code, the default action.
C0C4: CD63C0  			call 	CompileByte 				; e.g. the word compiles a call to whatever follows it.
C0C7: 214AC0  			ld 		hl,CompileCallFollowing
C0CA: CD54C0  			call 	CompileWord
              	
C0CD:         	_COPopHLExit:
C0CD: E1      			pop 	hl 							; restore HL and exit.
C0CE: C9      			ret
              	;
              	; 		Compile or execute the word at HL.
              	;
C0CF:         	_COExecuteCompile:
C0CF: E5      			push 	hl 							; save word text address
C0D0: CDAEC1  			call 	SearchDictionary 			; try to find it in the dictionary
C0D3: 7C      			ld 		a,h 						; was it found ?
C0D4: B5      			or 		l
C0D5: 284B    			jr 		z,_CECUnknown
              			;
              			; 		Word in the dictionary.
              			;
C0D7: D1      			pop 	de 							; get word text back in DE
C0D8: CB46    			bit 	0,(hl) 						; is this execute only ?
C0DA: 2808    			jr 		z,_CECNotCompileOnly
C0DC: 1A      			ld 		a,(de)  					; what are we doing with it ?
C0DD: E6C0    			and 	$C0  						; get colour
C0DF: FE80    			cp 		$80  						; if execute ?
C0E1: CA37C0  			jp 		z,WordIsCompileOnly 		; then we have an error.
C0E4:         	_CECNotCompileOnly:		
C0E4: 1A      			ld 		a,(de) 						; get the word colour and save on the stack
C0E5: E6C0    			and 	$C0
C0E7: F5      			push	af
              	
C0E8: ED5B1EC0			ld 		de,(CodeNextFree) 			; save the current code position on the stack.
C0EC: D5      			push 	de 
              	
C0ED: CD1CC1  			call 	_COCallRoutine 				; call the routine to compile what it does.
              	
C0F0:         	_CEExecuteOrCompile:		
C0F0: E1      			pop 	hl 							; restore code position at start to HL.
C0F1: F1      			pop 	af 							; restore word colour.
              	
C0F2: FE80    			cp 	 	$80 						; if not execute
C0F4: 20D7    			jr 	 	nz,_COPopHLExit 			; then return, as we've done the compile
              	
C0F6: 3EC9    			ld 		a,$C9 						; this is the Z80 RET which we need to compile after the code
C0F8: CD63C0  			call 	CompileByte
C0FB: 221EC0  			ld 		(CodeNextFree),hl 			; reset the code pointer, as we don't want to keep this executed word.
              	
C0FE: 110FC1  			ld 		de,_CEXContinue 			; go here on return
C101: D5      			push 	de
C102: E5      			push 	hl 							; go here, the newly compiled code, first, this is for the RET below
              	
C103: 2A24C0  			ld 		hl,(RegA) 					; load registers
C106: ED5B26C0			ld 		de,(RegB) 					
C10A: ED4B28C0			ld 		bc,(RegC) 					
              	
C10E: C9      			ret 								; execute the code, as we pushed HL - not actually returning :)
              	
C10F:         	_CEXContinue:
C10F: 2224C0  			ld 		(RegA),hl 					; save the registers
C112: ED5326C0			ld 		(RegB),de
C116: ED4328C0			ld 		(RegC),bc
              	
C11A: 18B1    			jr 		_COPopHLExit 				; pop HL and exit
              			;
              			; 		Call the routine to compile the code.
              			;
C11C:         	_COCallRoutine:
C11C: 23      			inc 	hl 							; call address into DE
C11D: 5E      			ld 		e,(hl)
C11E: 23      			inc 	hl
C11F: 56      			ld 		d,(hl)
C120: EB      			ex 		de,hl 						; and go there
C121:         	_COCallHL:		
C121: E9      			jp 		(hl)
              			;
              			; 		Word not in the dictionary. Could be a constant or a string 
              			;
C122:         	_CECUnknown:		
C122: E1      			pop 	hl 							; restore word address.
C123: 7E      			ld 		a,(hl) 						; look at the first character
C124: E63F    			and 	$3F
C126: FE22    			cp 		$22 						; is it a quote, indicating a string.
C128: 282E    			jr 		z,_CSTRProcess 
              			;
              			; 		Now it must be a constant
              			;
C12A: 7E      			ld 		a,(hl) 						; push the colour on the stack
C12B: E6C0    			and 	$C0
C12D: F5      			push 	af
C12E: CDE7C1  			call 	StringToInteger 			; convert a word to a valid integer.
C131: 7A      			ld 		a,d 						; DE = 0 if fail.
C132: B3      			or 		e
C133: CA3AC0  			jp 		z,UnknownWord 
              			;
C136: F1      			pop 	af  
C137: FE80    			cp 		$80 						; if execute, do execute constant.
C139: 280F    			jr 		z,_CECExecuteConstant
              			;
              			; 		Compile a constant inline.
              			;
C13B:         	_CECCompileConstant:		
C13B: 3EEB    			ld 		a,$EB 						; compile EX DE,HL
C13D: CD63C0  			call 	CompileByte
C140: 3E21    			ld 		a,$21 						; LD HL,xxxxx
C142: CD63C0  			call 	CompileByte
C145: CD54C0  			call 	CompileWord 				; compile the number to load
C148: 1883    			jr 		_COPopHLExit 				; and exit
              			;
              			; 		Do the equivalent of executing a constant e.g. swap A & B n=>A
              			;
C14A:         	_CECExecuteConstant:
C14A: ED5B24C0			ld 		de,(RegA) 					; A -> B
C14E: ED5326C0			ld 		(RegB),de
C152: 2224C0  			ld 		(RegA),hl 					; constant -> HL
C155: C3CDC0  			jp 		_COPopHLExit 				; and exit
              			;
              			; 		HL points to a string, prefixed by a ". Note, this is transient in execute mode.
              			;
C158:         	_CSTRProcess:
C158: 7E      			ld 		a,(hl) 						; push colour on stack
C159: E6C0    			and 	$C0
C15B: F5      			push 	af
C15C: ED5B1EC0			ld 		de,(CodeNextFree) 			; save the current code position on the stack.
C160: D5      			push 	de 
              	
C161: E5      			push 	hl 							; save string address
C162: 3ECD    			ld 		a,$CD 						; compile CALL StringConstantHandler
C164: CD63C0  			call 	CompileByte 				
C167: 21A5C1  			ld 		hl,StringConstantHandler
C16A: CD54C0  			call 	CompileWord
C16D: E1      			pop 	hl
C16E: 23      			inc 	hl 							; skip over the initial single quote
C16F:         	_CSTRLoop:
C16F: 7E      			ld 		a,(hl) 						; reached the end ? either 00 orr coloured space.
C170: B7      			or 		a
C171: 2820    			jr 		z,_CSTRDone
C173: E63F    			and 	$3F
C175: FE20    			cp 		$20
C177: 281A    			jr 		z,_CSTRDone		
C179: EE20    			xor 	$20 						; convert back to ASCII 7 bit.
C17B: C620    			add 	$20
C17D: FE41    			cp 		'A' 						; make lower case as default.
C17F: 3806    			jr 		c,_CSTRNotAlpha
C181: FE5B    			cp 		'Z'+1
C183: 3002    			jr 		nc,_CSTRNotAlpha
C185: C620    			add 	$20
C187:         	_CSTRNotAlpha:		
C187: FE5F    			cp 		'_' 						; map _ to space
C189: 2002    			jr 		nz,_CSTRNotBar
C18B: 3E20    			ld 		a,' '
C18D:         	_CSTRNotBar:		
C18D: CD63C0  			call 	CompileByte  				; write out
C190: 23      			inc 	hl 							; next byte
C191: 18DC    			jr 		_CSTRLoop
C193:         	_CSTRDone:
C193: AF      			xor 	a 							; write $00 end of string
C194: CD63C0  			call 	CompileByte
C197: C3F0C0  			jp 		_CEExecuteOrCompile 		; and go do it, perhaps.		
              	
              	; ***************************************************************************************
              	;
              	; 						Write dictionary word out working downwards
              	;
              	; ***************************************************************************************
              	
C19A:         	CompileWriteDictionary:
C19A: E5      			push 	hl
C19B: 2A22C0  			ld 		hl,(DictionaryBase) 		; hence pre-decrement address.
C19E: 2B      			dec 	hl
C19F: 77      			ld 		(hl),a
C1A0: 2222C0  			ld 		(DictionaryBase),hl
C1A3: E1      			pop 	hl
C1A4: C9      			ret
              	
              	; ***************************************************************************************
              	;
              	;					 Put in HL the ASCIIZ constant following
              	;
              	; ***************************************************************************************
              	
C1A5:         	StringConstantHandler:
C1A5: E1      			pop 	hl 							; get the return address into HL, leave on stack		
C1A6: E5      			push 	hl
C1A7:         	_SCHEnd: 									; advance HL past the string
C1A7: 7E      			ld 		a,(hl)
C1A8: 23      			inc 	hl
C1A9: B7      			or 		a
C1AA: 20FB    			jr 		nz,_SCHEnd		
C1AC: E3      			ex 		(sp),hl 					; swap them round, so HL = start and (SP) is the byte after
C1AD: C9      			ret
              		.include 	"search.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		find.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		16th October 2021
              	;		Purpose :	Search dictionary
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	; 		Search dictionary for word at HL, which is internal format (2+6 ended with 
              	;		(2+space or $00). On exit HL points to the type byte or $0000 if not found.
              	;
              	; ***************************************************************************************
              	
C1AE:         	SearchDictionary:
C1AE: C5      			push 	bc
C1AF: D5      			push 	de
C1B0: EB      			ex 		de,hl 						; put search string address in DE.
C1B1: 2A22C0  			ld 		hl,(DictionaryBase) 		; HL points to dictionary base.
              			;
              			; 		Compare entry at HL vs word at DE
              			;
C1B4:         	_SearchLoop:
C1B4: 44      			ld 		b,h 						; copy current being searched to BC
C1B5: 4D      			ld 		c,l 								
C1B6: 7E      			ld 		a,(hl) 						; get the type byte.
C1B7: B7      			or 	 	a 							; if zero, then fail as we've reached dictionary end.
C1B8: 2827    			jr 		z,_SDFail
              			;
C1BA: 23      			inc  	hl 							; point to the first character
C1BB: 23      			inc 	hl 							; e.g. skip type byte and call address.
C1BC: 23      			inc 	hl
C1BD: D5      			push 	de 							; save search string address on stack.
              			;
              			; 		Compare string at HL vs String at DE
              			;
C1BE:         	_SearchCompare:
C1BE: 1A      			ld 		a,(de) 						; calculate xor of two characters
C1BF: AE      			xor 	(hl) 						; as we're only interested in lower 6 bits for compare
C1C0: E63F    			and 	$3F 						; check lower 6 bits only.
C1C2: 2015    			jr 		nz,_SearchNext 				; different, go to next word.
C1C4: 7E      			ld 		a,(hl) 						; get dictionary byte successfully matched.
C1C5: 13      			inc 	de 							; advance to next.
C1C6: 23      			inc 	hl 		
C1C7: 87      			add 	a,a 						; is bit 7 in the last match, indicating the last character of the word in the dictionary ?
C1C8: 30F4    			jr 		nc,_SearchCompare 			; no, keep comparing
              			;
              			; 		Found the end of the word in the dictionary, HL points to the byte following, DE the character following.
              			;	 	We need to check it's the end of the word in the search text.
              			;
C1CA: 1A      			ld 		a,(de) 						; get the next character in the search word.
C1CB: D1      			pop 	de 							; having got the character, restore DE to original value.
C1CC: B7      			or 		a 							; is it $00 or xx10000 (any colour space)
C1CD: 2806    			jr 		z,_SDSucceed 				; if zero, we've found the word, end of buffer
C1CF: E63F    			and 	$3F 
C1D1: FE20    			cp 		$20
C1D3: 20DF    			jr 		nz,_SearchLoop 				; no it wasn't any Space so go round again. HL points to the next type byte already.
C1D5:         	_SDSucceed: 
C1D5: 60      			ld 		h,b 						; restore value saved in BC to HL, the type byte address of the found word.
C1D6: 69      			ld 		l,c  						; at the start, e.g. the address of the type byte.
C1D7: 180B    			jr 		_SDExit
              			;
              			; 		Names did not match. HL still points into the word.
              			;
C1D9:         	_SearchNext:
C1D9: 7E      			ld 		a,(hl) 						; get and bump in dictionary
C1DA: 23      			inc 	hl
C1DB: 87      			add 	a,a 						; looking for the bit 7 set indicating the end of the word
C1DC: 30FB    			jr 		nc,_SearchNext  			
C1DE: D1      			pop 	de 							; restore DE, the address of the input word
C1DF: 18D3    			jr 		_SearchLoop 				; and try the next dictionary word.
              	;
C1E1:         	_SDFail:									; not found, return zero
C1E1: 210000  			ld 		hl,$0000 					
C1E4:         	_SDExit:
C1E4: D1      			pop 	de
C1E5: C1      			pop 	bc		
C1E6: C9      			ret		
              	
              	
              		.include 	"toint.asm"
              	; ***************************************************************************************
              	; ***************************************************************************************
              	;
              	;		Name : 		toint.asm
              	;		Author :	Paul Robson (paul@robsons.org.uk)
              	;		Date : 		16th October 2021
              	;		Purpose :	Convert a word to an integer.
              	;
              	; ***************************************************************************************
              	; ***************************************************************************************
              	
              	; ***************************************************************************************
              	;
              	;		Convert word to integer. Can be decimal $hexadecimal and prefixed with '-'
              	;		Result in HL, DE is non-zero if successful.
              	;
              	; ***************************************************************************************
              	
C1E7:         	StringToInteger:
C1E7: 7E      			ld 		a,(hl) 						; check for - x
C1E8: E63F    			and 	$3F
C1EA: FE2D    			cp 		'-'
C1EC: 200C    			jr 		nz,_STOInt
C1EE: 23      			inc 	hl 							; skip the - sign. 
C1EF: CDFAC1  			call 	_STOInt 					; try to convert to integer
              	
C1F2: 7C      			ld 		a,h 						; negate the result.
C1F3: 2F      			cpl 
C1F4: 67      			ld 		h,a
C1F5: 7D      			ld 		a,l
C1F6: 2F      			cpl
C1F7: 6F      			ld 		l,a
C1F8: 23      			inc 	hl
C1F9: C9      			ret
              	
C1FA: DDE5    	_STOInt:push 	ix 							; save IX
              			
              	
C1FC: E5      			push 	hl 							; copy word address to IX
C1FD: DDE1    			pop 	ix		
C1FF: 01000A  			ld 		bc,10*256 					; base in B, count in C
C202: 210000  			ld 		hl,0 						; result in HL.
              			;
C205: DD7E00  			ld 		a,(ix+0) 					; is first character a '$'
C208: E63F    			and 	$3F
C20A: FE24    			cp 		'$'
C20C: 2004    			jr 		nz,_STONotHex 
              			;
C20E: 0610    			ld 		b,16 						; now Base 16.
C210: DD23    			inc 	ix 							; skip over the '$'
C212:         	_STONotHex:
              			;
              			; 		Main processing loop.
              			;		
C212:         	_STOLoop:
C212: DD7E00  			ld 		a,(ix+0) 					; get character
C215: DD23    			inc 	ix
C217: B7      			or 		a  							; check for $00 or Coloured space
C218: 282F    			jr 		z,_STOEndWord 					
C21A: E63F    			and 	$3F
C21C: FE20    			cp 		$20
C21E: 2829    			jr 		z,_STOEndWord
              			;
C220: FE3A    			cp 		'9'+1 						; if > 9 then fail
C222: 3029    			jr 		nc,_STOFail
C224: FE30    			cp 		'0'
C226: 3009    			jr 		nc,_STOOkay
C228: FE07    			cp 		6+1 						; if > F then fail
C22A: 3021    			jr 		nc,_STOFail
C22C: B7      			or 		a
C22D: 281E    			jr 		z,_STOFail 					; $00 is a fail too.
C22F: C609    			add 	9 							; maps A ($01) to ($0A) etc.
C231:         	_STOOkay:
C231: 0C      			inc 	c 							; increment successful char count		
C232: E60F    			and 	$0F 						; make digit in range 0..15
C234: B8      			cp 		b 							; fail if >= the base
C235: 3016    			jr 		nc,_STOFail
              			;
C237: 29      			add 	hl,hl 						; HL = 2 * HL
C238: 5D      			ld 		e,l 						; DE = 2 * HL
C239: 54      			ld 		d,h		
C23A: 29      			add 	hl,hl 						; HL = 4 * HL
C23B: 29      			add 	hl,hl 						; HL = 8 * HL
C23C: CB60    			bit 	4,b 						; is base 16 ?
C23E: 2802    			jr 		z,_STONotHexMult
C240: 5D      			ld 		e,l 						; if base 16 HL = DE = 8 * HL
C241: 54      			ld 		d,h
C242:         	_STONotHexMult:
C242: 19      			add 	hl,de 						; so HL = HL * 10 or * 16 depending on B
C243: 5F      			ld 		e,a 						; put digit in DE and add
C244: 1600    			ld 		d,0
C246: 19      			add 	hl,de
C247: 18C9    			jr 		_STOLoop
              	;
C249:         	_STOEndWord:
C249: 59      			ld 		e,c 						; E is 0 if no chars, e.g. fail or #0 if chars consumed
C24A: 51      			ld 		d,c 						; D the same
C24B: 1806    			jr 		_STOExit 					; and exit
              	
C24D:         	_STOFail:	 								; can't do it, return DE = HL = 0	
C24D: 110000  			ld 		de,0
C250: 210000  			ld 		hl,0
C253:         	_STOExit:		
C253: DDE1    			pop 	ix 							; restore IX and exit
C255: C9      			ret
              	
              			
              		
              	
              	; ***************************************************************************************
              	;
              	; 							Autogenerated Vocabulary file
              	;
              	; ***************************************************************************************
              	
              		.include 	"vocabulary/vocabulary.asm"
              	; --------------------------------------
              	;             <
              	; --------------------------------------
C256:         	word_1000:
C256: CD4AC0  		call	CompileCallFollowing
C259: 7C      	 ld   a,h           ; check if signs different.
C25A: AA      	 xor  d
C25B: 87      	 add  a,a          ; CS if different
C25C: 3004    	 jr   nc,__less_samesign
C25E: 7A      	 ld   a,d          ; different. set CS to sign of B
C25F: 87      	 add  a,a          ; if set (negative) B must be < A as A is +ve
C260: 1805    	 jr   __less_returnc
C262:         	__less_samesign:
C262: D5      	 push  de           ; save DE
C263: EB      	 ex   de,hl          ; -1 if B < A
C264: ED52    	 sbc  hl,de          ; calculate B - A , hencs CS if < (Carry clear by add a,a)
C266: D1      	 pop  de           ; restore DE
C267:         	__less_returnc:
C267: 3E00    	 ld   a,0          ; A 0
C269: DE00    	 sbc  a,0          ; A $FF if CS.
C26B: 6F      	 ld   l,a          ; put in HL
C26C: 67      	 ld   h,a
C26D: C9      	 ret
              	; --------------------------------------
              	;             =
              	; --------------------------------------
C26E:         	word_1001:
C26E: CD4AC0  		call	CompileCallFollowing
C271: 7C      	 ld   a,h          ; H = H ^ D
C272: AA      	 xor  d
C273: 67      	 ld   h,a
C274: 7D      	 ld   a,l          ; A = (L ^ E) | (H ^ D)
C275: AB      	 xor  e
C276: B4      	 or   h           ; if A == 0 they are the same.
C277: 210000  	 ld   hl,$0000         ; return 0 if different
C27A: C0      	 ret  nz
C27B: 2B      	 dec  hl           ; return -1
C27C: C9      	 ret
              	; --------------------------------------
              	;             -
              	; --------------------------------------
C27D:         	word_1002:
C27D: CD4AC0  		call	CompileCallFollowing
C280: D5      	 push  de           ; save DE
C281: EB      	 ex   de,hl          ; HL = B, DE = A
C282: AF      	 xor  a            ; clear carry
C283: ED52    	 sbc  hl,de          ; calculate B-A
C285: D1      	 pop  de           ; restore DE
C286: C9      	 ret
              	; --------------------------------------
              	;             +
              	; --------------------------------------
C287:         	word_1003:
C287: CD3DC0  		call	CopyFollowing
C28A: 01      		.db	endcopy_1003 - $ - 1
C28B: 19      	 add  hl,de
C28C:         	endcopy_1003:
              	; --------------------------------------
              	;             AND
              	; --------------------------------------
C28C:         	word_1004:
C28C: CD4AC0  		call	CompileCallFollowing
C28F: 7C      	 ld   a,h
C290: A2      	 and  d
C291: 67      	 ld   h,a
C292: 7D      	 ld   a,l
C293: A3      	 and  e
C294: 6F      	 ld   l,a
C295: C9      	 ret
              	; --------------------------------------
              	;             OR
              	; --------------------------------------
C296:         	word_1005:
C296: CD4AC0  		call	CompileCallFollowing
C299: 7C      	 ld   a,h
C29A: B2      	 or   d
C29B: 67      	 ld   h,a
C29C: 7D      	 ld   a,l
C29D: B3      	 or   e
C29E: 6F      	 ld   l,a
C29F: C9      	 ret
              	; --------------------------------------
              	;             XOR
              	; --------------------------------------
C2A0:         	word_1006:
C2A0: CD4AC0  		call	CompileCallFollowing
C2A3: 7C      	 ld   a,h
C2A4: AA      	 xor  d
C2A5: 67      	 ld   h,a
C2A6: 7D      	 ld   a,l
C2A7: AB      	 xor  e
C2A8: 6F      	 ld   l,a
C2A9: C9      	 ret
              	; --------------------------------------
              	;             /
              	; --------------------------------------
C2AA:         	word_1007:
C2AA: CD4AC0  		call	CompileCallFollowing
C2AD: D5      	 push  de
C2AE: CD3DC4  	 call  DIVDivideMod16
C2B1: EB      	 ex   de,hl
C2B2: D1      	 pop  de
C2B3: C9      	 ret
              	; --------------------------------------
              	;             MOD
              	; --------------------------------------
C2B4:         	word_1008:
C2B4: CD4AC0  		call	CompileCallFollowing
C2B7: D5      	 push  de
C2B8: CD3DC4  	 call  DIVDivideMod16
C2BB: D1      	 pop  de
C2BC: C9      	 ret
              	; --------------------------------------
              	;             !
              	; --------------------------------------
C2BD:         	word_1009:
C2BD: CD3DC0  		call	CopyFollowing
C2C0: 04      		.db	endcopy_1009 - $ - 1
C2C1: 73      	  ld   (hl),e
C2C2: 23      	  inc  hl
C2C3: 72      	  ld   (hl),d
C2C4: 2B      	  dec  hl
C2C5:         	endcopy_1009:
              	; --------------------------------------
              	;             @
              	; --------------------------------------
C2C5:         	word_1010:
C2C5: CD3DC0  		call	CopyFollowing
C2C8: 04      		.db	endcopy_1010 - $ - 1
C2C9: 7E      	  ld   a,(hl)
C2CA: 23      	  inc  hl
C2CB: 66      	  ld  h,(hl)
C2CC: 6F      	  ld  l,a
C2CD:         	endcopy_1010:
              	; --------------------------------------
              	;             +!
              	; --------------------------------------
C2CD:         	word_1011:
C2CD: CD4AC0  		call	CompileCallFollowing
C2D0: 7E      	  ld   a,(hl)
C2D1: 83      	  add  a,e
C2D2: 77      	  ld   (hl),a
C2D3: 23      	  inc  hl
C2D4: 7E      	  ld   a,(hl)
C2D5: 8A      	  adc  a,d
C2D6: 77      	  ld   (hl),a
C2D7: 2B      	  dec  hl
C2D8: C9      	  ret
              	; --------------------------------------
              	;             C!
              	; --------------------------------------
C2D9:         	word_1012:
C2D9: CD3DC0  		call	CopyFollowing
C2DC: 01      		.db	endcopy_1012 - $ - 1
C2DD: 73      	  ld   (hl),e
C2DE:         	endcopy_1012:
              	; --------------------------------------
              	;             C@
              	; --------------------------------------
C2DE:         	word_1013:
C2DE: CD3DC0  		call	CopyFollowing
C2E1: 03      		.db	endcopy_1013 - $ - 1
C2E2: 6E      	  ld   l,(hl)
C2E3: 2600    	  ld   h,0
C2E5:         	endcopy_1013:
              	; --------------------------------------
              	;             P@
              	; --------------------------------------
C2E5:         	word_1014:
C2E5: CD3DC0  		call	CopyFollowing
C2E8: 04      		.db	endcopy_1014 - $ - 1
C2E9: ED68    	  in   l,(c)
C2EB: 2600    	  ld   h,0
C2ED:         	endcopy_1014:
              	; --------------------------------------
              	;             P!
              	; --------------------------------------
C2ED:         	word_1015:
C2ED: CD3DC0  		call	CopyFollowing
C2F0: 02      		.db	endcopy_1015 - $ - 1
C2F1: ED69    	  out  (c),l
C2F3:         	endcopy_1015:
              	; --------------------------------------
              	;             ,
              	; --------------------------------------
C2F3:         	word_1016:
C2F3: CD4AC0  		call	CompileCallFollowing
C2F6: C354C0  	  jp   CompileWord
              	; --------------------------------------
              	;             ;
              	; --------------------------------------
C2F9:         	word_1017:
C2F9: 3EC9    	  ld   a,$C9         ; compile a RET
C2FB: CD63C0  	  call  CompileByte
              	  ; TODO: Check close to $E000,  so we can skip the ROM header.
C2FE: C9      	  ret
              	; --------------------------------------
              	;             C,
              	; --------------------------------------
C2FF:         	word_1018:
C2FF: CD4AC0  		call	CompileCallFollowing
C302: 7D      	  ld   a,l
C303: C363C0  	  jp   CompileByte
              	; --------------------------------------
              	;             COPY
              	; --------------------------------------
C306:         	word_1019:
C306: CD4AC0  		call	CompileCallFollowing
C309: 78      	  ld   a,b         ; exit if C = 0
C30A: B1      	  or   c
C30B: C8      	  ret  z
              	
C30C: C5      	  push  bc          ; BC count
C30D: D5      	  push  de          ; DE target
C30E: E5      	  push  hl          ; HL source
              	
C30F: AF      	  xor  a          ; Clear C
C310: ED52    	  sbc  hl,de         ; check overlap ?
C312: 300B    	  jr   nc,__copy_gt_count      ; if source after target
C314: 19      	  add  hl,de         ; undo subtract
              	
C315: 09      	  add  hl,bc         ; add count to HL + DE
C316: EB      	  ex   de,hl
C317: 09      	  add  hl,bc
C318: EB      	  ex   de,hl
C319: 1B      	  dec  de          ; dec them, so now at the last byte to copy
C31A: 2B      	  dec  hl
C31B: EDB8    	  lddr           ; do it backwards
C31D: 1803    	  jr   __copy_exit
              	
C31F:         	__copy_gt_count:
C31F: 19      	  add  hl,de         ; undo subtract
C320: EDB0    	  ldir          ; do the copy
C322:         	__copy_exit:
C322: E1      	  pop  hl          ; restore registers
C323: D1      	  pop  de
C324: C1      	  pop  bc
C325: C9      	  ret
              	; --------------------------------------
              	;             FILL
              	; --------------------------------------
C326:         	word_1020:
C326: CD4AC0  		call	CompileCallFollowing
C329: 78      	  ld   a,b         ; exit if C = 0
C32A: B1      	  or   c
C32B: C8      	  ret  z
              	
C32C: C5      	  push  bc          ; BC count
C32D: D5      	  push  de          ; DE target, L byte
C32E:         	__fill_loop:
C32E: 7D      	  ld   a,l         ; copy a byte
C32F: 12      	  ld   (de),a
C330: 13      	  inc  de          ; bump pointer
C331: 0B      	  dec  bc          ; dec counter and loop
C332: 78      	  ld   a,b
C333: B1      	  or   c
C334: 20F8    	  jr   nz,__fill_loop
C336: D1      	  pop  de          ; restore
C337: C1      	  pop  bc
C338: C9      	  ret
              	; --------------------------------------
              	;             HALT
              	; --------------------------------------
C339:         	word_1021:
C339: CD4AC0  		call	CompileCallFollowing
C33C:         	__halt_loop:
C33C: F3      	  di
C33D: 76      	  halt
C33E: 18FC    	  jr   __halt_loop
              	; --------------------------------------
              	;             BREAK
              	; --------------------------------------
C340:         	word_1022:
C340: CD3DC0  		call	CopyFollowing
C343: 01      		.db	endcopy_1022 - $ - 1
C344: 76      	  db   $76
C345:         	endcopy_1022:
              	; --------------------------------------
              	;             *
              	; --------------------------------------
C345:         	word_1023:
C345: CD4AC0  		call	CompileCallFollowing
C348: C368C4  	 jp   MULTMultiply16
              	; --------------------------------------
              	;             SWAP
              	; --------------------------------------
C34B:         	word_1024:
C34B: CD3DC0  		call	CopyFollowing
C34E: 01      		.db	endcopy_1024 - $ - 1
C34F: EB      	  ex   de,hl
C350:         	endcopy_1024:
              	; --------------------------------------
              	;             A>B
              	; --------------------------------------
C350:         	word_1025:
C350: CD3DC0  		call	CopyFollowing
C353: 02      		.db	endcopy_1025 - $ - 1
C354: 54      	  ld   d,h
C355: 5D      	  ld   e,l
C356:         	endcopy_1025:
              	; --------------------------------------
              	;             A>C
              	; --------------------------------------
C356:         	word_1026:
C356: CD3DC0  		call	CopyFollowing
C359: 02      		.db	endcopy_1026 - $ - 1
C35A: 44      	  ld   b,h
C35B: 4D      	  ld   c,l
C35C:         	endcopy_1026:
              	; --------------------------------------
              	;             B>A
              	; --------------------------------------
C35C:         	word_1027:
C35C: CD3DC0  		call	CopyFollowing
C35F: 02      		.db	endcopy_1027 - $ - 1
C360: 62      	  ld   h,d
C361: 6B      	  ld   l,e
C362:         	endcopy_1027:
              	; --------------------------------------
              	;             B>C
              	; --------------------------------------
C362:         	word_1028:
C362: CD3DC0  		call	CopyFollowing
C365: 02      		.db	endcopy_1028 - $ - 1
C366: 42      	  ld   b,d
C367: 4B      	  ld   c,e
C368:         	endcopy_1028:
              	; --------------------------------------
              	;             C>A
              	; --------------------------------------
C368:         	word_1029:
C368: CD3DC0  		call	CopyFollowing
C36B: 02      		.db	endcopy_1029 - $ - 1
C36C: 60      	  ld   h,b
C36D: 69      	  ld   l,c
C36E:         	endcopy_1029:
              	; --------------------------------------
              	;             C>B
              	; --------------------------------------
C36E:         	word_1030:
C36E: CD3DC0  		call	CopyFollowing
C371: 02      		.db	endcopy_1030 - $ - 1
C372: 50      	  ld   d,b
C373: 59      	  ld   e,c
C374:         	endcopy_1030:
              	; --------------------------------------
              	;             PUSH
              	; --------------------------------------
C374:         	word_1031:
C374: CD3DC0  		call	CopyFollowing
C377: 01      		.db	endcopy_1031 - $ - 1
C378: E5      	 push  hl
C379:         	endcopy_1031:
              	; --------------------------------------
              	;             POP
              	; --------------------------------------
C379:         	word_1032:
C379: CD3DC0  		call	CopyFollowing
C37C: 02      		.db	endcopy_1032 - $ - 1
C37D: EB      	 ex   de,hl
C37E: E1      	 pop  hl
C37F:         	endcopy_1032:
              	; --------------------------------------
              	;             A>R
              	; --------------------------------------
C37F:         	word_1033:
C37F: CD3DC0  		call	CopyFollowing
C382: 01      		.db	endcopy_1033 - $ - 1
C383: E5      	 push  hl
C384:         	endcopy_1033:
              	; --------------------------------------
              	;             R>A
              	; --------------------------------------
C384:         	word_1034:
C384: CD3DC0  		call	CopyFollowing
C387: 01      		.db	endcopy_1034 - $ - 1
C388: E1      	 pop  hl
C389:         	endcopy_1034:
              	; --------------------------------------
              	;             B>R
              	; --------------------------------------
C389:         	word_1035:
C389: CD3DC0  		call	CopyFollowing
C38C: 01      		.db	endcopy_1035 - $ - 1
C38D: D5      	 push  de
C38E:         	endcopy_1035:
              	; --------------------------------------
              	;             R>B
              	; --------------------------------------
C38E:         	word_1036:
C38E: CD3DC0  		call	CopyFollowing
C391: 01      		.db	endcopy_1036 - $ - 1
C392: D1      	 pop  de
C393:         	endcopy_1036:
              	; --------------------------------------
              	;             C>R
              	; --------------------------------------
C393:         	word_1037:
C393: CD3DC0  		call	CopyFollowing
C396: 01      		.db	endcopy_1037 - $ - 1
C397: C5      	 push  bc
C398:         	endcopy_1037:
              	; --------------------------------------
              	;             R>C
              	; --------------------------------------
C398:         	word_1038:
C398: CD3DC0  		call	CopyFollowing
C39B: 01      		.db	endcopy_1038 - $ - 1
C39C: C1      	 pop  bc
C39D:         	endcopy_1038:
              	; --------------------------------------
              	;             AB>R
              	; --------------------------------------
C39D:         	word_1039:
C39D: CD3DC0  		call	CopyFollowing
C3A0: 02      		.db	endcopy_1039 - $ - 1
C3A1: D5      	 push  de
C3A2: E5      	 push  hl
C3A3:         	endcopy_1039:
              	; --------------------------------------
              	;             R>AB
              	; --------------------------------------
C3A3:         	word_1040:
C3A3: CD3DC0  		call	CopyFollowing
C3A6: 02      		.db	endcopy_1040 - $ - 1
C3A7: E1      	 pop  hl
C3A8: D1      	 pop  de
C3A9:         	endcopy_1040:
              	; --------------------------------------
              	;             ABC>R
              	; --------------------------------------
C3A9:         	word_1041:
C3A9: CD3DC0  		call	CopyFollowing
C3AC: 03      		.db	endcopy_1041 - $ - 1
C3AD: C5      	 push  bc
C3AE: D5      	 push  de
C3AF: E5      	 push  hl
C3B0:         	endcopy_1041:
              	; --------------------------------------
              	;             R>ABC
              	; --------------------------------------
C3B0:         	word_1042:
C3B0: CD3DC0  		call	CopyFollowing
C3B3: 03      		.db	endcopy_1042 - $ - 1
C3B4: E1      	 pop  hl
C3B5: D1      	 pop  de
C3B6: C1      	 pop  bc
C3B7:         	endcopy_1042:
              	; --------------------------------------
              	;             H
              	; --------------------------------------
C3B7:         	word_1043:
C3B7: CD3DC0  		call	CopyFollowing
C3BA: 03      		.db	endcopy_1043 - $ - 1
C3BB: 211EC0  	  ld  hl,CodeNextFree
C3BE:         	endcopy_1043:
              	; --------------------------------------
              	;             ---
              	; --------------------------------------
C3BE:         	word_1044:
C3BE: CD3DC0  		call	CopyFollowing
C3C1: 02      		.db	endcopy_1044 - $ - 1
C3C2: 2B      	  dec  hl
C3C3: 2B      	  dec  hl
C3C4:         	endcopy_1044:
              	; --------------------------------------
              	;             --
              	; --------------------------------------
C3C4:         	word_1045:
C3C4: CD3DC0  		call	CopyFollowing
C3C7: 01      		.db	endcopy_1045 - $ - 1
C3C8: 2B      	  dec  hl
C3C9:         	endcopy_1045:
              	; --------------------------------------
              	;             ++
              	; --------------------------------------
C3C9:         	word_1046:
C3C9: CD3DC0  		call	CopyFollowing
C3CC: 01      		.db	endcopy_1046 - $ - 1
C3CD: 23      	  inc  hl
C3CE:         	endcopy_1046:
              	; --------------------------------------
              	;             +++
              	; --------------------------------------
C3CE:         	word_1047:
C3CE: CD3DC0  		call	CopyFollowing
C3D1: 02      		.db	endcopy_1047 - $ - 1
C3D2: 23      	  inc  hl
C3D3: 23      	  inc  hl
C3D4:         	endcopy_1047:
              	; --------------------------------------
              	;             0-
              	; --------------------------------------
C3D4:         	word_1048:
C3D4: CD4AC0  		call	CompileCallFollowing
C3D7:         	__negate:
C3D7: 7C      	  ld   a,h
C3D8: 2F      	  cpl
C3D9: 67      	  ld   h,a
C3DA: 7D      	  ld   a,l
C3DB: 2F      	  cpl
C3DC: 6F      	  ld   l,a
C3DD: 23      	  inc  hl
C3DE: C9      	  ret
              	; --------------------------------------
              	;             0<
              	; --------------------------------------
C3DF:         	word_1049:
C3DF: CD4AC0  		call	CompileCallFollowing
C3E2: CB7C    	  bit  7,h
C3E4: 210000  	  ld   hl,$0000
C3E7: C8      	  ret  z
C3E8: 2B      	  dec  hl
C3E9: C9      	  ret
              	; --------------------------------------
              	;             0=
              	; --------------------------------------
C3EA:         	word_1050:
C3EA: CD4AC0  		call	CompileCallFollowing
C3ED: 7C      	  ld   a,h
C3EE: B5      	  or   l
C3EF: 210000  	  ld   hl,$0000
C3F2: C0      	  ret  nz
C3F3: 2B      	  dec  hl
C3F4: C9      	  ret
              	; --------------------------------------
              	;             2*
              	; --------------------------------------
C3F5:         	word_1051:
C3F5: CD3DC0  		call	CopyFollowing
C3F8: 01      		.db	endcopy_1051 - $ - 1
C3F9: 29      	  add  hl,hl
C3FA:         	endcopy_1051:
              	; --------------------------------------
              	;             4*
              	; --------------------------------------
C3FA:         	word_1052:
C3FA: CD3DC0  		call	CopyFollowing
C3FD: 02      		.db	endcopy_1052 - $ - 1
C3FE: 29      	  add  hl,hl
C3FF: 29      	  add  hl,hl
C400:         	endcopy_1052:
              	; --------------------------------------
              	;             8*
              	; --------------------------------------
C400:         	word_1053:
C400: CD3DC0  		call	CopyFollowing
C403: 03      		.db	endcopy_1053 - $ - 1
C404: 29      	  add  hl,hl
C405: 29      	  add  hl,hl
C406: 29      	  add  hl,hl
C407:         	endcopy_1053:
              	; --------------------------------------
              	;             16*
              	; --------------------------------------
C407:         	word_1054:
C407: CD3DC0  		call	CopyFollowing
C40A: 04      		.db	endcopy_1054 - $ - 1
C40B: 29      	  add  hl,hl
C40C: 29      	  add  hl,hl
C40D: 29      	  add  hl,hl
C40E: 29      	  add  hl,hl
C40F:         	endcopy_1054:
              	; --------------------------------------
              	;             2/
              	; --------------------------------------
C40F:         	word_1055:
C40F: CD3DC0  		call	CopyFollowing
C412: 04      		.db	endcopy_1055 - $ - 1
C413: CB2C    	  sra  h
C415: CB1D    	  rr   l
C417:         	endcopy_1055:
              	; --------------------------------------
              	;             4/
              	; --------------------------------------
C417:         	word_1056:
C417: CD3DC0  		call	CopyFollowing
C41A: 08      		.db	endcopy_1056 - $ - 1
C41B: CB2C    	  sra  h
C41D: CB1D    	  rr   l
C41F: CB2C    	  sra  h
C421: CB1D    	  rr   l
C423:         	endcopy_1056:
              	; --------------------------------------
              	;             ABS
              	; --------------------------------------
C423:         	word_1057:
C423: CD4AC0  		call	CompileCallFollowing
C426: CB7C    	  bit  7,h
C428: C8      	  ret  z
C429: C3D7C3  	  jp   __negate
              	; --------------------------------------
              	;             BSWAP
              	; --------------------------------------
C42C:         	word_1058:
C42C: CD3DC0  		call	CopyFollowing
C42F: 03      		.db	endcopy_1058 - $ - 1
C430: 7D      	  ld   a,l
C431: 6C      	  ld   l,h
C432: 67      	  ld   h,a
C433:         	endcopy_1058:
              	; --------------------------------------
              	;             NOT
              	; --------------------------------------
C433:         	word_1059:
C433: CD4AC0  		call	CompileCallFollowing
C436: 7C      	  ld   a,h
C437: 2F      	  cpl
C438: 67      	  ld   h,a
C439: 7D      	  ld   a,l
C43A: 2F      	  cpl
C43B: 6F      	  ld   l,a
C43C: C9      	  ret
              	
              	
              	
C43D:         	DIVDivideMod16:
C43D: C5      	 push  bc
C43E: 42      	 ld   b,d     ; DE
C43F: 4B      	 ld   c,e
C440: EB      	 ex   de,hl
C441: 210000  	 ld   hl,0
C444: 78      	 ld   a,b
C445: 0608    	 ld   b,8
C447:         	Div16_Loop1:
C447: 17      	 rla
C448: ED6A    	 adc  hl,hl
C44A: ED52    	 sbc  hl,de
C44C: 3001    	 jr   nc,Div16_NoAdd1
C44E: 19      	 add  hl,de
C44F:         	Div16_NoAdd1:
C44F: 10F6    	 djnz  Div16_Loop1
C451: 17      	 rla
C452: 2F      	 cpl
C453: 47      	 ld   b,a
C454: 79      	 ld   a,c
C455: 48      	 ld   c,b
C456: 0608    	 ld   b,8
C458:         	Div16_Loop2:
C458: 17      	 rla
C459: ED6A    	 adc  hl,hl
C45B: ED52    	 sbc  hl,de
C45D: 3001    	 jr   nc,Div16_NoAdd2
C45F: 19      	 add  hl,de
C460:         	Div16_NoAdd2:
C460: 10F6    	 djnz  Div16_Loop2
C462: 17      	 rla
C463: 2F      	 cpl
C464: 51      	 ld   d,c
C465: 5F      	 ld   e,a
C466: C1      	 pop  bc
C467: C9      	 ret
C468:         	MULTMultiply16:
C468: C5      	  push  bc
C469: D5      	  push  de
C46A: 44      	  ld   b,h        ; get multipliers in DE/BC
C46B: 4D      	  ld   c,l
C46C: 210000  	  ld   hl,0        ; zero total
C46F:         	__Core__Mult_Loop:
C46F: CB41    	  bit  0,c        ; lsb of shifter is non-zero
C471: 2801    	  jr   z,__Core__Mult_Shift
C473: 19      	  add  hl,de        ; add adder to total
C474:         	__Core__Mult_Shift:
C474: CB38    	  srl  b         ; shift BC right.
C476: CB19    	  rr   c
C478: EB      	  ex   de,hl        ; shift DE left
C479: 29      	  add  hl,hl
C47A: EB      	  ex   de,hl
C47B: 78      	  ld   a,b        ; loop back if BC is nonzero
C47C: B1      	  or   c
C47D: 20F0    	  jr   nz,__Core__Mult_Loop
C47F: D1      	  pop  de
C480: C1      	  pop  bc
C481: C9      	  ret
C482:         	FreeSpace:
              	
              	; ***************************************************************************************
              	;
              	;										ROM Header
              	;
              	; ***************************************************************************************
              	
C482: FFFFFFFF		.org	$E000
C486: FF...   	
E000: 50535200		.db  	"PSR",0 						; 4 bytes filler.
E004: 009C00B0		.db  	0,$9C,0,$B0,0,$6C 				; 12 bytes ROM Identify
E008: 006C    	
E00A: 006400A8		.db 	0,$64,0,$A8,$5F,$70 			; the $5F makes the total $70 so $00 is output to scrambler
E00E: 5F70    	
              		.org 	$E010
E010: C300C0  		jp 		start 							; BIOS enters here.
              	
              	
E013:         	testCode:
              		.include "test/test.inc"
E013: C1C4C4F5		.db	$c1,$c4,$c4,$f5,$60,$75,$60,$6b,$60,$7b,$a0,$b1,$b0,$a0,$81,$84,$84,$b5,$a0,$81,$84,$84,$b5,$a0,$81,$be,$83,$a0,$88,$a0,$81,$be,$82,$a0,$80,$0
E017: 6075606B	
E01B: 607BA0B1	
E01F: B0A08184	
E023: 84B5A081	
E027: 8484B5A0	
E02B: 81BE83A0	
E02F: 88A081BE	
E033: 82A08000	
              	
              	
              	; ***************************************************************************************
              	;
              	; 				Load the Dictionary into High memory, it works down.
              	;
              	; ***************************************************************************************
              	
              		.include "vocabulary/dictionary.inc" 	; get length
0151:         	DictionarySize = 337
E037: FFFFFFFF		.org 	CodeEnd-DictionarySize+1 		; set start pointer
E03B: FF...   	
FEAF:         	DictionaryInstalledBase:
              		.include "vocabulary/dictionary.asm" 	; pregenerated dictionary.
              	; <
FEAF: 80      		.db	$80
FEB0: 56C2    		.dw	word_1000
FEB2: BC      		.db	$bc
              	; =
FEB3: 80      		.db	$80
FEB4: 6EC2    		.dw	word_1001
FEB6: BD      		.db	$bd
              	; -
FEB7: 80      		.db	$80
FEB8: 7DC2    		.dw	word_1002
FEBA: AD      		.db	$ad
              	; +
FEBB: 80      		.db	$80
FEBC: 87C2    		.dw	word_1003
FEBE: AB      		.db	$ab
              	; AND
FEBF: 80      		.db	$80
FEC0: 8CC2    		.dw	word_1004
FEC2: 010E84  		.db	$1,$e,$84
              	; OR
FEC5: 80      		.db	$80
FEC6: 96C2    		.dw	word_1005
FEC8: 0F92    		.db	$f,$92
              	; XOR
FECA: 80      		.db	$80
FECB: A0C2    		.dw	word_1006
FECD: 180F92  		.db	$18,$f,$92
              	; /
FED0: 80      		.db	$80
FED1: AAC2    		.dw	word_1007
FED3: AF      		.db	$af
              	; MOD
FED4: 80      		.db	$80
FED5: B4C2    		.dw	word_1008
FED7: 0D0F84  		.db	$d,$f,$84
              	; !
FEDA: 80      		.db	$80
FEDB: BDC2    		.dw	word_1009
FEDD: A1      		.db	$a1
              	; @
FEDE: 80      		.db	$80
FEDF: C5C2    		.dw	word_1010
FEE1: 80      		.db	$80
              	; +!
FEE2: 80      		.db	$80
FEE3: CDC2    		.dw	word_1011
FEE5: 2BA1    		.db	$2b,$a1
              	; C!
FEE7: 80      		.db	$80
FEE8: D9C2    		.dw	word_1012
FEEA: 03A1    		.db	$3,$a1
              	; C@
FEEC: 80      		.db	$80
FEED: DEC2    		.dw	word_1013
FEEF: 0380    		.db	$3,$80
              	; P@
FEF1: 80      		.db	$80
FEF2: E5C2    		.dw	word_1014
FEF4: 1080    		.db	$10,$80
              	; P!
FEF6: 80      		.db	$80
FEF7: EDC2    		.dw	word_1015
FEF9: 10A1    		.db	$10,$a1
              	; ,
FEFB: 80      		.db	$80
FEFC: F3C2    		.dw	word_1016
FEFE: AC      		.db	$ac
              	; ;
FEFF: 81      		.db	$81
FF00: F9C2    		.dw	word_1017
FF02: BB      		.db	$bb
              	; C,
FF03: 80      		.db	$80
FF04: FFC2    		.dw	word_1018
FF06: 03AC    		.db	$3,$ac
              	; COPY
FF08: 80      		.db	$80
FF09: 06C3    		.dw	word_1019
FF0B: 030F1099		.db	$3,$f,$10,$99
              	; FILL
FF0F: 80      		.db	$80
FF10: 26C3    		.dw	word_1020
FF12: 06090C8C		.db	$6,$9,$c,$8c
              	; HALT
FF16: 80      		.db	$80
FF17: 39C3    		.dw	word_1021
FF19: 08010C94		.db	$8,$1,$c,$94
              	; BREAK
FF1D: 80      		.db	$80
FF1E: 40C3    		.dw	word_1022
FF20: 02120501		.db	$2,$12,$5,$1,$8b
FF24: 8B      	
              	; *
FF25: 80      		.db	$80
FF26: 45C3    		.dw	word_1023
FF28: AA      		.db	$aa
              	; SWAP
FF29: 80      		.db	$80
FF2A: 4BC3    		.dw	word_1024
FF2C: 13170190		.db	$13,$17,$1,$90
              	; A>B
FF30: 80      		.db	$80
FF31: 50C3    		.dw	word_1025
FF33: 013E82  		.db	$1,$3e,$82
              	; A>C
FF36: 80      		.db	$80
FF37: 56C3    		.dw	word_1026
FF39: 013E83  		.db	$1,$3e,$83
              	; B>A
FF3C: 80      		.db	$80
FF3D: 5CC3    		.dw	word_1027
FF3F: 023E81  		.db	$2,$3e,$81
              	; B>C
FF42: 80      		.db	$80
FF43: 62C3    		.dw	word_1028
FF45: 023E83  		.db	$2,$3e,$83
              	; C>A
FF48: 80      		.db	$80
FF49: 68C3    		.dw	word_1029
FF4B: 033E81  		.db	$3,$3e,$81
              	; C>B
FF4E: 80      		.db	$80
FF4F: 6EC3    		.dw	word_1030
FF51: 033E82  		.db	$3,$3e,$82
              	; PUSH
FF54: 81      		.db	$81
FF55: 74C3    		.dw	word_1031
FF57: 10151388		.db	$10,$15,$13,$88
              	; POP
FF5B: 81      		.db	$81
FF5C: 79C3    		.dw	word_1032
FF5E: 100F90  		.db	$10,$f,$90
              	; A>R
FF61: 81      		.db	$81
FF62: 7FC3    		.dw	word_1033
FF64: 013E92  		.db	$1,$3e,$92
              	; R>A
FF67: 81      		.db	$81
FF68: 84C3    		.dw	word_1034
FF6A: 123E81  		.db	$12,$3e,$81
              	; B>R
FF6D: 81      		.db	$81
FF6E: 89C3    		.dw	word_1035
FF70: 023E92  		.db	$2,$3e,$92
              	; R>B
FF73: 81      		.db	$81
FF74: 8EC3    		.dw	word_1036
FF76: 123E82  		.db	$12,$3e,$82
              	; C>R
FF79: 81      		.db	$81
FF7A: 93C3    		.dw	word_1037
FF7C: 033E92  		.db	$3,$3e,$92
              	; R>C
FF7F: 81      		.db	$81
FF80: 98C3    		.dw	word_1038
FF82: 123E83  		.db	$12,$3e,$83
              	; AB>R
FF85: 81      		.db	$81
FF86: 9DC3    		.dw	word_1039
FF88: 01023E92		.db	$1,$2,$3e,$92
              	; R>AB
FF8C: 81      		.db	$81
FF8D: A3C3    		.dw	word_1040
FF8F: 123E0182		.db	$12,$3e,$1,$82
              	; ABC>R
FF93: 81      		.db	$81
FF94: A9C3    		.dw	word_1041
FF96: 0102033E		.db	$1,$2,$3,$3e,$92
FF9A: 92      	
              	; R>ABC
FF9B: 81      		.db	$81
FF9C: B0C3    		.dw	word_1042
FF9E: 123E0102		.db	$12,$3e,$1,$2,$83
FFA2: 83      	
              	; H
FFA3: 80      		.db	$80
FFA4: B7C3    		.dw	word_1043
FFA6: 88      		.db	$88
              	; ---
FFA7: 80      		.db	$80
FFA8: BEC3    		.dw	word_1044
FFAA: 2D2DAD  		.db	$2d,$2d,$ad
              	; --
FFAD: 80      		.db	$80
FFAE: C4C3    		.dw	word_1045
FFB0: 2DAD    		.db	$2d,$ad
              	; ++
FFB2: 80      		.db	$80
FFB3: C9C3    		.dw	word_1046
FFB5: 2BAB    		.db	$2b,$ab
              	; +++
FFB7: 80      		.db	$80
FFB8: CEC3    		.dw	word_1047
FFBA: 2B2BAB  		.db	$2b,$2b,$ab
              	; 0-
FFBD: 80      		.db	$80
FFBE: D4C3    		.dw	word_1048
FFC0: 30AD    		.db	$30,$ad
              	; 0<
FFC2: 80      		.db	$80
FFC3: DFC3    		.dw	word_1049
FFC5: 30BC    		.db	$30,$bc
              	; 0=
FFC7: 80      		.db	$80
FFC8: EAC3    		.dw	word_1050
FFCA: 30BD    		.db	$30,$bd
              	; 2*
FFCC: 80      		.db	$80
FFCD: F5C3    		.dw	word_1051
FFCF: 32AA    		.db	$32,$aa
              	; 4*
FFD1: 80      		.db	$80
FFD2: FAC3    		.dw	word_1052
FFD4: 34AA    		.db	$34,$aa
              	; 8*
FFD6: 80      		.db	$80
FFD7: 00C4    		.dw	word_1053
FFD9: 38AA    		.db	$38,$aa
              	; 16*
FFDB: 80      		.db	$80
FFDC: 07C4    		.dw	word_1054
FFDE: 3136AA  		.db	$31,$36,$aa
              	; 2/
FFE1: 80      		.db	$80
FFE2: 0FC4    		.dw	word_1055
FFE4: 32AF    		.db	$32,$af
              	; 4/
FFE6: 80      		.db	$80
FFE7: 17C4    		.dw	word_1056
FFE9: 34AF    		.db	$34,$af
              	; ABS
FFEB: 80      		.db	$80
FFEC: 23C4    		.dw	word_1057
FFEE: 010293  		.db	$1,$2,$93
              	; BSWAP
FFF1: 80      		.db	$80
FFF2: 2CC4    		.dw	word_1058
FFF4: 02131701		.db	$2,$13,$17,$1,$90
FFF8: 90      	
              	; NOT
FFF9: 80      		.db	$80
FFFA: 33C4    		.dw	word_1059
FFFC: 0E0F94  		.db	$e,$f,$94
FFFF: 00      		.db	$00


total time: 0.0102 sec.
no errors
